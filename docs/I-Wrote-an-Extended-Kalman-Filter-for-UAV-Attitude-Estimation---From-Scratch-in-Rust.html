<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>I Wrote an Extended Kalman Filter for UAV Attitude Estimation — From Scratch in Rust</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">I Wrote an Extended Kalman Filter for UAV Attitude Estimation — From Scratch in Rust</h1>
</header>
<section data-field="subtitle" class="p-summary">
Part of my custom Rust-based UAV project, this EKF delivers real-time attitude estimation from raw IMU data using quaternions.
</section>
<section data-field="body" class="e-content">
<section name="e9d8" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="f887" id="f887" class="graf graf--h3 graf--leading graf--title">I Wrote an Extended Kalman Filter for UAV Attitude Estimation — From Scratch in Rust</h3><h4 name="e57b" id="e57b" class="graf graf--h4 graf-after--h3 graf--subtitle">Part of my custom Rust-based UAV project, this EKF delivers real-time attitude estimation from raw IMU data using quaternions.</h4><figure name="d8be" id="d8be" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*b2yFqt3gCEOajCsyfx5cuQ.png" data-width="1738" data-height="1160" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*b2yFqt3gCEOajCsyfx5cuQ.png"><figcaption class="imageCaption"><em class="markup--em markup--figure-em">Photo by </em><a href="https://unsplash.com/@asoggetti" data-href="https://unsplash.com/@asoggetti" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank"><em class="markup--em markup--figure-em">Alessio Soggetti</em></a><em class="markup--em markup--figure-em"> on </em><a href="https://unsplash.com/photos/turned-on-drone-rSFxBGpnluw" data-href="https://unsplash.com/photos/turned-on-drone-rSFxBGpnluw" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank"><em class="markup--em markup--figure-em">Unsplash</em></a></figcaption></figure><h3 name="c795" id="c795" class="graf graf--h3 graf-after--figure">TL;DR</h3><p name="e215" id="e215" class="graf graf--p graf-after--h3">I built a quaternion-based Extended Kalman Filter (EKF) for quadcopter attitude estimation — from scratch in Rust. The filter fuses gyroscope and accelerometer data into a fast, robust 3D orientation estimate suitable for real-time embedded systems.</p><p name="becd" id="becd" class="graf graf--p graf-after--p">In software-in-the-loop (SITL) tests, the EKF processed 1 million IMU samples in under 1 second, while hardware testing via a ROS2 perception pipeline demonstrated that the EKF accurately tracks orientation in real time at 1kHz — even capturing the subtle unsteadiness of hand motion. This article covers:</p><ul class="postList"><li name="2288" id="2288" class="graf graf--li graf-after--p">Why I chose quaternions over Euler angles and other design decisions</li><li name="97a1" id="97a1" class="graf graf--li graf-after--li">How the EKF prediction and update steps work</li><li name="23ff" id="23ff" class="graf graf--li graf-after--li">Full Rust implementation and tuning using SITL and hardware testing</li><li name="eb85" id="eb85" class="graf graf--li graf-after--li">Performance benchmarks and real-time visualization in ROS2 (RViz2, rqt_plot)</li></ul><p name="2eca" id="2eca" class="graf graf--p graf-after--li">This is one piece of a larger UAV project, with next steps including magnetometer integration for yaw correction, full quadcopter hardware assembly, and a cascaded PID control layer for stable flight.</p><p name="403a" id="403a" class="graf graf--p graf-after--p">🔗 <a href="https://github.com/OrlandoQuintana/rust-ekf" data-href="https://github.com/OrlandoQuintana/rust-ekf" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">View the code on GitHub</a></p><h3 name="7616" id="7616" class="graf graf--h3 graf-after--p">Table of Contents</h3><ol class="postList"><li name="01af" id="01af" class="graf graf--li graf-after--h3">Introduction</li><li name="1826" id="1826" class="graf graf--li graf-after--li">Extended Kalman Filter Purpose</li><li name="91cb" id="91cb" class="graf graf--li graf-after--li">Design Decisions<br>3.1 Quaternion Estimation vs. Euler Estimation<br>3.2 Expanded State Vector<br>3.3 Yaw Angle<br>3.4 Gyroscope Bias<br>3.5 Programming Language: Rust<br>3.6 Modularity and Expandability</li><li name="5f43" id="5f43" class="graf graf--li graf-after--li">What You Need to Actually Run This<br>4.1 System Requirements (The Basics)<br>4.2 Practical Requirements (The Harder Part)<br>4.3 Generalization</li><li name="54c6" id="54c6" class="graf graf--li graf-after--li">Filter Initialization<br>5.1 Fixed-Size Types<br>5.2 The EKF Struct<br>5.3 Initializing the Filter<br>5.4 Noise Matrices and Tuning<br>5.5 Initialization Wrap-Up</li><li name="799d" id="799d" class="graf graf--li graf-after--li">The Extended Kalman Filter<br>6.1 Prediction Phase<br>6.1.1 Compute the Dynamic Model: f(x, u)<br>6.1.2 Compute the Dynamic Jacobian<br>6.1.3 Update the Covariance Matrix<br>6.2 Update Phase<br>6.2.1 Compute the Measurement Model: h(x,u)<br>6.2.2 Compute Innovation<br>6.2.3 Compute the Measurement Jacobian<br>6.2.4 Compute the Innovation Covariance<br>6.2.5 Calculate the Kalman Gain (K)<br>6.2.6 Update the State Vector<br>6.2.7 Update the Covariance Matrix<br>6.2.8 Normalize the Quaternion</li><li name="471d" id="471d" class="graf graf--li graf-after--li">Implementation and Results<br>7.1 Software-in-the-Loop (SITL) Testing<br>7.2 SITL Results<br>7.3 Hardware-in-the-Loop (HITL) Testing<br>7.4 Yaw Locked for Focused Tuning<br>7.5 Filter Tuning and Visualization<br>7.6 Hardware Testing Conclusion</li><li name="09bd" id="09bd" class="graf graf--li graf-after--li">Next Steps</li><li name="b132" id="b132" class="graf graf--li graf-after--li">Conclusion</li><li name="a4a4" id="a4a4" class="graf graf--li graf-after--li">Resources</li></ol><h3 name="d1c8" id="d1c8" class="graf graf--h3 graf-after--li">1. Introduction</h3><p name="c5b0" id="c5b0" class="graf graf--p graf-after--h3">Quadcopters and UAVs are everywhere — from consumer drones by <strong class="markup--strong markup--p-strong">DJI</strong> to autonomous systems from <strong class="markup--strong markup--p-strong">Anduril</strong>. As these flying machines get smarter, one technology becomes indispensable: real-time attitude estimation.</p><p name="4ac3" id="4ac3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">I’m building my own UAV — from scratch, in Rust — and this is one of the most critical subsystems.</strong></p><p name="faab" id="faab" class="graf graf--p graf-after--p">Accurate orientation estimation is the backbone of stable flight and autonomous navigation. Whether you’re launching a drone, stabilizing a satellite, or building a self-balancing robot, you need to fuse noisy sensor data into a reliable 3D orientation. Many implementations lean on Euler angles and Python but I took a different path.</p><p name="58bf" id="58bf" class="graf graf--p graf-after--p">This article presents a complete implementation of a <strong class="markup--strong markup--p-strong">quaternion-based Extended Kalman Filter (EKF)</strong>, developed in Rust, that fuses gyroscope and accelerometer data (with built-in bias correction) into a robust orientation estimate. The filter is designed not only for simulation — demonstrated through software-in-the-loop (SITL) testing — but also for real-world deployment. I integrated low-level SPI drivers and built a ROS2-based real-time perception pipeline that validates the filter using actual sensor data.</p><p name="df8c" id="df8c" class="graf graf--p graf-after--p">But this article isn’t just a build log.</p><p name="5033" id="5033" class="graf graf--p graf-after--p">It’s a deep dive into quaternion math, sensor fusion, Kalman filtering, and what it takes to implement real-time robotics systems in Rust. If you’ve ever wondered how to turn raw IMU data into a rock-solid orientation estimate — <strong class="markup--strong markup--p-strong">this is the guide I wish existed when I started.</strong></p><figure name="08a7" id="08a7" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*a620REezu-DrLhW2Ztyc5A.jpeg" data-width="2581" data-height="1936" src="https://cdn-images-1.medium.com/max/800/1*a620REezu-DrLhW2Ztyc5A.jpeg"><figcaption class="imageCaption"><em class="markup--em markup--figure-em">Photo by </em><a href="https://www.pexels.com/@masoodaslami/" data-href="https://www.pexels.com/@masoodaslami/" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank"><em class="markup--em markup--figure-em">Masood Aslami</em></a><em class="markup--em markup--figure-em"> on </em><a href="https://www.pexels.com/photo/small-mavic-drone-hovering-with-camera-11178057/" data-href="https://www.pexels.com/photo/small-mavic-drone-hovering-with-camera-11178057/" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank"><em class="markup--em markup--figure-em">Pexels</em></a></figcaption></figure><h3 name="fb1d" id="fb1d" class="graf graf--h3 graf-after--figure">2. Extended Kalman Filter Purpose</h3><p name="6395" id="6395" class="graf graf--p graf-after--h3">Accurate attitude estimation is critical for quadcopter control — but there’s no sensor that can measure “attitude” directly. Instead, we combine noisy, partial measurements with physical models of the world to estimate the true orientation of a flying object. The key is to fuse multiple sensors, each with different strengths and weaknesses, into one coherent belief about the system’s state.</p><p name="a648" id="a648" class="graf graf--p graf-after--p">For attitude estimation, the two most widely used sensors are the gyroscope and the accelerometer:</p><ul class="postList"><li name="751d" id="751d" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Gyroscope</strong>: Measures angular velocity with high precision over short timescales. But without an external reference, its measurements slowly drift due to integration errors.</li><li name="c18a" id="c18a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Accelerometer</strong>: The accelerometer acts as a correction mechanism during the update phase. It uses gravity — a constant, global reference — to pull the estimate back toward reality.</li></ul><p name="f042" id="f042" class="graf graf--p graf-after--li">Used individually, each sensor has serious drawbacks. But together, they’re complementary.</p><p name="79a4" id="79a4" class="graf graf--p graf-after--p">This fusion of fast but drifting gyro data with slow but stable accelerometer data is the core idea behind <em class="markup--em markup--p-em">sensor fusion</em> — and the <em class="markup--em markup--p-em">Kalman filter</em> is the mathematical framework that makes it possible.</p><p name="d9ff" id="d9ff" class="graf graf--p graf-after--p">A Kalman Filter is an iterative algorithm for estimating the state of a dynamic system from noisy and partial measurements. It’s recursive and efficient, making it ideal for real-time applications. It operates in two steps:</p><ul class="postList"><li name="36ea" id="36ea" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Predict:</strong> Use your model of the system (and short-term sensors) to estimate the new state.</li><li name="11b1" id="11b1" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Update</strong>: Use new sensor data (long-term references) to correct the estimate and reduce uncertainty.</li></ul><p name="5ac0" id="5ac0" class="graf graf--p graf-after--li">In our case, the gyroscope feeds the prediction step, and the accelerometer drives the update step, combining into a robust estimate of orientation over time.</p><p name="1505" id="1505" class="graf graf--p graf-after--p">Because orientation in 3D space is a nonlinear problem (especially when using quaternions), we use the Extended Kalman Filter (EKF) — a nonlinear variant of the classic Kalman filter that linearizes the system at each step.</p><h3 name="eb26" id="eb26" class="graf graf--h3 graf-after--p">3. Design Decisions</h3><p name="94f0" id="94f0" class="graf graf--p graf-after--h3">The Extended Kalman Filter is an extremely customizeable tool that requires an intimate understanding of both the dynamic system and the goal of the implementation. This is particularly true when being integrated in a larger robotics system whose downstream processes rely on the output of the filter. For that reason, many design decisions must be made before even a single equation is derived or single line of code is written to make sure the filter is being used to the best of its ability.</p><h3 name="6a0b" id="6a0b" class="graf graf--h3 graf-after--p">3.1 Quaternion Estimaton vs. Euler Estimation</h3><p name="a17b" id="a17b" class="graf graf--p graf-after--h3">Aircraft attitude is often described using Euler angles (roll, pitch, and yaw). Euler angles are intuitive and easy to understand because they provide a 3D representation of the aircraft’s orientation in space. However, they come with significant drawbacks that make them less suitable for real-time attitude estimation in dynamic systems like quadcopters. These drawbacks include:</p><ol class="postList"><li name="0ecc" id="0ecc" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Gimbal Lock</strong>: A mathematical singularity that occurs when one of the Euler angles reaches ±90° (e.g., pitch = 90°). In this state, the system loses one degree of freedom, making it impossible to represent certain orientations. This can lead to numerical instability and unpredictable behavior in control systems.</li><li name="44e8" id="44e8" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Angle Wrapping</strong>: Euler angles are cyclic, meaning they wrap around at ±180° or 360°. This creates discontinuities that require manual handling, such as unwrapping angles, which complicates algorithms and introduces potential errors.</li><li name="5eae" id="5eae" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Computational Complexity</strong>: Combining multiple rotations using Euler angles requires trigonometric functions (e.g., sine and cosine), which are computationally expensive and can lead to performance bottlenecks in real-time systems.</li></ol><p name="9780" id="9780" class="graf graf--p graf-after--li">To address these issues, this EKF implementation uses quaternions for attitude estimation. Quaternions are a four-dimensional representation of orientation made up of a scalar <code class="markup--code markup--p-code">w</code> and a vector <code class="markup--code markup--p-code">[x, y, z]</code>. These values together form a quaternion, which can be written as <code class="markup--code markup--p-code">q = w + xi + yj + zk</code>. Quaternions offer several advantages including:</p><ol class="postList"><li name="c17e" id="c17e" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">No Gimbal Lock</strong>: Quaternions avoid singularities entirely, ensuring smooth and continuous representation of all possible orientations.</li><li name="dfbd" id="dfbd" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">No Angle Wrapping</strong>: Quaternions do not suffer from cyclic discontinuities, eliminating the need for angle unwrapping and simplifying algorithms.</li><li name="4195" id="4195" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Computational Efficiency</strong>: Quaternion operations (e.g. multiplication, interpolation) are computationally efficient and avoid the need for trigonometric functions, making them ideal for real-time systems.</li><li name="0b73" id="0b73" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Robustness</strong>: Quaternions provide a more stable and numerically robust representation of orientation, especially in dynamic systems like quadcopters where rapid changes in attitude are common.</li></ol><p name="e3f2" id="e3f2" class="graf graf--p graf-after--li">By using quaternions, this <strong class="markup--strong markup--p-strong">Extended Kalman Filter (EKF) implementation achieves smoother and more reliable attitude estimation</strong>, making it well-suited for real-world robotics applications like quadcopter control.</p><h3 name="0276" id="0276" class="graf graf--h3 graf-after--p">3.2 Expanded State Vector</h3><p name="07cf" id="07cf" class="graf graf--p graf-after--h3">Many aircraft attitude estimations using EKF, like one found in <em class="markup--em markup--p-em">Small Unmanned Aircraft: Theory and Practice</em> by Randall W. Beard and Timothy W. McLain (a key inspiration for this project) include only <strong class="markup--strong markup--p-strong">roll and pitch Euler angles</strong> in their state vectors. This is because only roll and pitch can be both predicted (using gyroscope data) and updated (using accelerometer data).</p><p name="840e" id="840e" class="graf graf--p graf-after--p">Yaw, however, cannot be updated by accelerometer data, as it is independent of gravity.</p><p name="498e" id="498e" class="graf graf--p graf-after--p">This EKF implementation takes a more comprehensive approach by:</p><ol class="postList"><li name="69a5" id="69a5" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Using Quaternions Instead of Euler Angles</strong>: The state vector includes a full quaternion (<code class="markup--code markup--li-code">w, x, y, z</code>) for orientation estimation, avoiding the limitations of Euler angles.</li><li name="d24a" id="d24a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Including Yaw Estimation</strong>: Despite not having a sensor (e.g., magnetometer or GPS) to update yaw directly, the state vector includes a gyroscope-derived yaw estimate as part of the prediction quaternion. This allows for a complete 3D orientation representation and supports future integration of yaw-correcting sensors in the update phase.</li><li name="5425" id="5425" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Adding Gyro Bias</strong>: The state vector also includes biases for all 3 axes to prevent drift in the prediction estimate.</li></ol><p name="6472" id="6472" class="graf graf--p graf-after--li">The full state vector is defined as:</p><ul class="postList"><li name="7590" id="7590" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">w</strong>: The real part of the quaternion</li><li name="31e7" id="31e7" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">x</strong>: The coefficient of the <code class="markup--code markup--li-code">i</code> component.</li><li name="7186" id="7186" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">y</strong>: The coefficient of the <code class="markup--code markup--li-code">j</code> component.</li><li name="7048" id="7048" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">z</strong>: The coefficient of the <code class="markup--code markup--li-code">k</code> component.</li><li name="6124" id="6124" class="graf graf--li graf-after--li">bx: Gyroscope bias around the x-axis.</li><li name="dd83" id="dd83" class="graf graf--li graf-after--li">by: Gyroscope bias around the y-axis.</li><li name="0f92" id="0f92" class="graf graf--li graf-after--li">bz: Gyroscope bias around the z-axis.</li></ul><p name="9363" id="9363" class="graf graf--p graf-after--li">This expanded state vector provides a more comprehensive attitude estimation, <strong class="markup--strong markup--p-strong">making it adaptable to more complex systems and future sensor integrations.</strong></p><h4 name="2495" id="2495" class="graf graf--h4 graf-after--p">3.3 Yaw Angle</h4><ul class="postList"><li name="9a79" id="9a79" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">Why it’s critical</strong>: Yaw determines the quadcopter’s heading and is essential for navigation, waypoint following, and camera orientation. Without accurate yaw, the vehicle may drift or fail to stabilize correctly in global coordinates, even if roll and pitch are estimated perfectly.</li><li name="bb30" id="bb30" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Why it’s difficult</strong>: Yaw estimation is uniquely hard because it lacks an absolute reference in typical IMU setups. While roll and pitch relate directly to gravity (which the accelerometer can detect), yaw represents rotation about the gravity vector — meaning it’s invisible to the accelerometer.</li><li name="1553" id="1553" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Current approach</strong>: This EKF predicts yaw using gyroscope integration (through the quaternion’s dynamics), but does not update it. That means yaw will drift over time — but for many use cases (e.g. short flights, no global navigation), that drift is acceptable. Including yaw in the state vector now ensures the system is ready for future sensor fusion.</li><li name="1240" id="1240" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Why it’s still included</strong>: Even without yaw correction sensors, the system is structured to accept corrections from magnetometers, vision (e.g. SLAM pose), or GPS-based heading sensors in future updates. This avoids needing a full EKF redesign when those sensors are added.</li><li name="7fcf" id="7fcf" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Testing</strong>: In the absence of an external yaw reference (e.g., magnetometer or GPS), estimating full 3D orientation with a quaternion-based EKF becomes ill-posed due to yaw unobservability — especially at steep pitch or roll angles. To prevent drift and undefined behavior in the yaw axis, I explicitly “lock” yaw during testing. This simplifies the estimation problem to only roll and pitch (X and Y axes), which can be reliably estimated using accelerometer and gyroscope data. Locking yaw allows accurate testing and tuning of the EKF on real hardware using only the onboard IMU sensors.</li></ul><h4 name="20b5" id="20b5" class="graf graf--h4 graf-after--li">3.4 Gyroscope Bias</h4><p name="7dc0" id="7dc0" class="graf graf--p graf-after--h4">Many attitude estimation filters omit the explicit estimation of gyroscope biases by relying solely on accelerometer-based corrections to counteract drift. However, by incorporating gyroscope biases into the state vector, several key benefits are achieved:</p><ul class="postList"><li name="8764" id="8764" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Drift Mitigation for Orientation: </strong>When integrating angular velocity to update the orientation, even a small constant bias can lead to significant drift over time. By estimating the bias, the EKF subtracts it from the raw gyro measurements before integration, ensuring that the quaternion remains stable and accurate in the long term.</li><li name="3f72" id="3f72" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Improved Accuracy in Orientation Estimation: </strong>The EKF uses bias-corrected angular velocity internally to update the quaternion state. This means that even if the raw gyro data contains noise and drift, the internal correction produces a more reliable orientation estimate. It’s important to note, however, that while the EKF computes a bias-corrected angular velocity for integration, the raw (or externally low-pass filtered) gyro measurements should still be used directly in control loops for instantaneous reaction.</li><li name="7bec" id="7bec" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Reduced Dependency on External Sensors: </strong>By continuously adjusting its bias estimate based on discrepancies between the predicted and measured accelerometer data, the EKF can maintain an accurate orientation without relying on the additional sensors in the update phase as heavily. This internal bias update helps “remember” and counteract the long-term drift inherent in the gyroscope.</li><li name="bfc7" id="bfc7" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Efficient Performance: </strong>Even with an expanded state vector that includes bias (resulting in a 7-state system rather than a 4-state system), the EKF remains computationally efficient — running at high frequencies on modern hardware. This tradeoff is minimal compared to the significant gains in long-term orientation accuracy.</li></ul><p name="b221" id="b221" class="graf graf--p graf-after--li">In summary, including gyroscope bias in the EKF state vector enables more accurate and stable quaternion integration. The EKF internally uses the bias-corrected angular velocity to update the orientation estimate, while raw gyro data (appropriately filtered) should be used for fast control tasks. This separation of roles ensures that the long-term drift in orientation is minimized without sacrificing the responsiveness required for real-time control.</p><figure name="5191" id="5191" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*3pE_NEHR9gvIP4oHCUCPEg.png" data-width="460" data-height="344" src="https://cdn-images-1.medium.com/max/800/1*3pE_NEHR9gvIP4oHCUCPEg.png"><figcaption class="imageCaption">Image: Ferris the Crab, by Karen Rustad Tölva. Used under CC BY-NC-ND 4.0. <a href="https://rustacean.net/" data-href="https://rustacean.net/" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">https://rustacean.net/</a></figcaption></figure><h3 name="870c" id="870c" class="graf graf--h3 graf-after--figure">3.5 Programming Language: Rust</h3><p name="0de0" id="0de0" class="graf graf--p graf-after--h3">The decision to implement this EKF in Rust — rather than C++, Python, or embedded C — was both technical and philosophical. <strong class="markup--strong markup--p-strong">Here’s why Rust was the right tool for the job</strong>:</p><ul class="postList"><li name="fbe8" id="fbe8" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Performance, without compromise</strong>: Rust compiles to native code with performance on par with C and C++. That’s essential for running the EKF at thousands of Hz on a Raspberry Pi. But unlike C++, Rust makes that performance safe by default. Rust’s ownership model enforces strict safety at compile time, making race conditions and segfaults nearly impossible — which is a huge win in robotics.</li><li name="26a0" id="26a0" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Zero-cost abstractions</strong>: With crates like <code class="markup--code markup--li-code">nalgebra</code>, Rust offers modern linear algebra tools without runtime penalties. This project relies heavily on matrix math and custom-sized vectors (e.g. 7x7 covariance matrices), and Rust&#39;s <code class="markup--code markup--li-code">nalgebra</code> crate handles them efficiently.</li><li name="0132" id="0132" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Ecosystem growth in robotics</strong>: Rust is rapidly gaining traction in robotics — from microcontroller support (<code class="markup--code markup--li-code">embedded-hal</code>, <code class="markup--code markup--li-code">rtic</code>) to full-blown ROS2 support via <code class="markup--code markup--li-code">ros2_rust</code>. By building this EKF in Rust, this project adds to a growing body of open-source work showing that Rust isn&#39;t just viable — it may be the future of embedded and real-time robotics development.</li><li name="2477" id="2477" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Clarity and correctness</strong>: The EKF is a tightly-coupled nonlinear estimator. Bugs can be subtle, and correctness is paramount. Rust’s compiler feels like having a second engineer who’s laser-focused on catching subtle bugs — before they become flight-ending crashes.</li></ul><p name="7328" id="7328" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">In short, Rust gave me the power of C++, the safety of functional languages, and the clarity of modern tooling — all without compromising performance. That combination makes it a near-perfect fit for robotics and state estimation systems like this one.</strong></p><h3 name="4e83" id="4e83" class="graf graf--h3 graf-after--p">3.6 Modularity and Expandability</h3><p name="bfeb" id="bfeb" class="graf graf--p graf-after--h3">The EKF implementation has been designed with modularity and future expandability in mind:</p><ul class="postList"><li name="fe93" id="fe93" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Modularity</strong>: Key matrices (state vector, covariance matrix, Q, and R) are defined in the EKF struct and initialized at creation, making the implementation easy to extend.</li><li name="e2de" id="e2de" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Expandability</strong>: The design anticipates adding more sensors (e.g., GPS, vision) to improve yaw correction and overall attitude estimation accuracy.</li></ul><p name="b09c" id="b09c" class="graf graf--p graf-after--li">These design decisions weren’t arbitrary — they reflect real constraints and goals: run fast on limited hardware, integrate tightly into a larger flight stack, and serve as a long-term foundation for autonomous quadrotor development. Every tradeoff here was made with one goal in mind: reliability in the real world.</p><h3 name="a890" id="a890" class="graf graf--h3 graf-after--p">4. What You Need to Actually Run This</h3><p name="4977" id="4977" class="graf graf--p graf-after--h3">Let’s talk about what it actually takes to get this EKF running in real time, on real hardware, with real sensors. These aren’t just academic equations — they’re tightly coupled to how data flows from an IMU into the estimator. Here’s what matters most:</p><h3 name="65da" id="65da" class="graf graf--h3 graf-after--p">4.1 System Requirements (The Basics)</h3><p name="945b" id="945b" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Rust Installation</strong><br>You’ll need Rust installed on your machine. If you haven’t used it before, the official Rust install guide will get you up and running quickly. Everything here is built with <code class="markup--code markup--p-code">cargo</code>.</p><p name="e81c" id="e81c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">IMU Data in the Right Units</strong></p><p name="e135" id="e135" class="graf graf--p graf-after--p">The EKF expects:</p><ul class="postList"><li name="4964" id="4964" class="graf graf--li graf-after--p">Gyroscope readings in radians/second</li><li name="ed69" id="ed69" class="graf graf--li graf-after--li">Accelerometer readings in meters/second²</li></ul><p name="a31b" id="a31b" class="graf graf--p graf-after--li">Most IMUs (like the ICM-20948 I used) will give you raw integer values that you’ll need to convert based on the sensor’s sensitivity settings. Don’t skip this step — incorrect units will silently kill your estimates.</p><p name="be06" id="be06" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Frame Alignment</strong><br>Your IMU’s orientation must match the standard EKF body frame:</p><p name="4d01" id="4d01" class="graf graf--p graf-after--p">x: Forward (North)</p><p name="b843" id="b843" class="graf graf--p graf-after--p">y: Right (East)</p><p name="603b" id="603b" class="graf graf--p graf-after--p">z: Down</p><p name="06c2" id="06c2" class="graf graf--p graf-after--p">If your sensor doesn’t match that (and most don’t), you’ll need to remap the axes and apply sign corrections. For example, the ICM-20948 I used had:</p><p name="f225" id="f225" class="graf graf--p graf-after--p">y: Forward</p><p name="b6e3" id="b6e3" class="graf graf--p graf-after--p">x: Right</p><p name="8129" id="8129" class="graf graf--p graf-after--p">z: Up</p><p name="ebbd" id="ebbd" class="graf graf--p graf-after--p">So I had to swap x and y, and flip the z-axis. Orientation mismatches are a silent killer — they won’t throw errors, but your quadcopter will drift, spin, or flip for reasons that seem mysterious until you check your axes.</p><figure name="b950" id="b950" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*VdS0mn1477kJVFikfW3NPw.jpeg" data-width="1002" data-height="992" src="https://cdn-images-1.medium.com/max/800/1*VdS0mn1477kJVFikfW3NPw.jpeg"><figcaption class="imageCaption"><em class="markup--em markup--figure-em">Expected IMU orientation</em></figcaption></figure><figure name="5ef3" id="5ef3" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*kEecl8nO3jJ6O4TC5BtZ8w.jpeg" data-width="825" data-height="565" src="https://cdn-images-1.medium.com/max/800/1*kEecl8nO3jJ6O4TC5BtZ8w.jpeg"><figcaption class="imageCaption"><em class="markup--em markup--figure-em">ICM-20948 orientation I had to correct</em></figcaption></figure><h3 name="c383" id="c383" class="graf graf--h3 graf-after--figure">4.2 Practical Requirements (The Harder Part)</h3><p name="8dd5" id="8dd5" class="graf graf--p graf-after--h3">Implementing an EKF isn’t plug-and-play — it requires you to understand the system you’re modeling. In this case, attitude estimation requires:</p><ul class="postList"><li name="6241" id="6241" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">A dynamic model</strong>: How the system evolves over time (here, how a quaternion changes based on angular velocity).</li><li name="2d5b" id="2d5b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">A measurement model</strong>: How sensor data relates to that state (here, how gravity appears in the body frame based on orientation).</li><li name="94e2" id="94e2" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Jacobians</strong>: Partial derivatives of both models with respect to the state vector — required to linearize the system for the EKF.</li></ul><p name="4470" id="4470" class="graf graf--p graf-after--li">These models are adapted from Small Unmanned Aircraft: Theory and Practice by Beard &amp; McLain, then modified to support quaternions and the expanded 7-state vector I used in this project. I’ll walk through the math in later sections, but if you’re porting this to a different system, you’ll need to rebuild the models for your dynamics.</p><h3 name="de28" id="de28" class="graf graf--h3 graf-after--p">4.3 Generalization</h3><p name="1261" id="1261" class="graf graf--p graf-after--h3">While this EKF is tailored for quadcopter attitude estimation using only gyro + accelerometer, the framework is extendable. Want to add:</p><ul class="postList"><li name="7426" id="7426" class="graf graf--li graf-after--p">Magnetometers for yaw correction?</li><li name="bf70" id="bf70" class="graf graf--li graf-after--li">GPS for global position fusion?</li><li name="5554" id="5554" class="graf graf--li graf-after--li">Camera-based SLAM?</li></ul><p name="aa76" id="aa76" class="graf graf--p graf-after--li">You’ll need to adjust your measurement model and potentially expand the state vector — but the core EKF structure remains the same.</p><h3 name="1b88" id="1b88" class="graf graf--h3 graf-after--p">5. Filter Initialization: Types, Structs, and Setup</h3><p name="64d5" id="64d5" class="graf graf--p graf-after--h3">Once the math was nailed down, it was time to bring this filter to life — and for that, I turned to Rust.</p><p name="248d" id="248d" class="graf graf--p graf-after--p">Why Rust? Because this project lives in the tight loop of a real-time robotics system. It needs to run at thousands of updates per second, handle matrix math without garbage collection pauses, and be safe enough to trust flying hardware. Rust delivers on all three — with zero-cost abstractions, stack-allocated linear algebra, and compile-time guarantees that catch bugs long before they cause crashes.</p><p name="f913" id="f913" class="graf graf--p graf-after--p">Let’s break down how the EKF is implemented.</p><h3 name="ec73" id="ec73" class="graf graf--h3 graf-after--p">5.1 Defining Fixed-Size Matrix Types with <code class="markup--code markup--h3-code">nalgebra</code></h3><p name="4cdd" id="4cdd" class="graf graf--p graf-after--h3">For a filter like this, linear algebra is everything — and I needed a way to express fixed-size vectors and matrices with both precision and performance.</p><p name="0421" id="0421" class="graf graf--p graf-after--p">Rust’s nalgebra crate makes this possible using const generics. Since my EKF has a 7-element state vector, I defined custom types like Vector7, Matrix7, and a few others for measurement Jacobians and quaternion math.</p><p name="71dd" id="71dd" class="graf graf--p graf-after--p">These types are known at compile time, live on the stack, and are fully type-safe. You can’t accidentally multiply incompatible matrices — the compiler won’t allow it. That’s the kind of rigor you want when debugging estimation errors at 7kHz.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="rust" name="b6e6" id="b6e6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">use</span> nalgebra::{Matrix, Matrix4, Const, Vector3};<br /><br /><span class="hljs-keyword">type</span> <span class="hljs-title class_">Vector7</span> = Matrix&lt;<span class="hljs-type">f64</span>, Const&lt;<span class="hljs-number">7</span>&gt;, Const&lt;<span class="hljs-number">1</span>&gt;, nalgebra::ArrayStorage&lt;<span class="hljs-type">f64</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>&gt;&gt;;<br /><span class="hljs-keyword">type</span> <span class="hljs-title class_">Matrix7</span> = Matrix&lt;<span class="hljs-type">f64</span>, Const&lt;<span class="hljs-number">7</span>&gt;, Const&lt;<span class="hljs-number">7</span>&gt;, nalgebra::ArrayStorage&lt;<span class="hljs-type">f64</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>&gt;&gt;;<br /><span class="hljs-keyword">type</span> <span class="hljs-title class_">Matrix3</span> = Matrix&lt;<span class="hljs-type">f64</span>, Const&lt;<span class="hljs-number">3</span>&gt;, Const&lt;<span class="hljs-number">3</span>&gt;, nalgebra::ArrayStorage&lt;<span class="hljs-type">f64</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>&gt;&gt;;<br /><span class="hljs-keyword">type</span> <span class="hljs-title class_">Matrix3x7</span> = Matrix&lt;<span class="hljs-type">f64</span>, Const&lt;<span class="hljs-number">3</span>&gt;, Const&lt;<span class="hljs-number">7</span>&gt;, nalgebra::ArrayStorage&lt;<span class="hljs-type">f64</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>&gt;&gt;;<br /><span class="hljs-keyword">type</span> <span class="hljs-title class_">Vector4</span> = Matrix&lt;<span class="hljs-type">f64</span>, Const&lt;<span class="hljs-number">4</span>&gt;, Const&lt;<span class="hljs-number">1</span>&gt;, nalgebra::ArrayStorage&lt;<span class="hljs-type">f64</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&gt;&gt;;</span></pre><p name="cdcb" id="cdcb" class="graf graf--p graf-after--pre">These types simplify the process of defining and manipulating matrices and vectors in our EKF implementation.</p><h3 name="1eb3" id="1eb3" class="graf graf--h3 graf-after--p">5.2 The EKF Struct</h3><p name="7bf0" id="7bf0" class="graf graf--p graf-after--h3">At the heart of the filter is the <code class="markup--code markup--p-code">EKF</code> struct — a container for the full estimator state, including the orientation estimate, covariance matrix, and noise models.</p><p name="5e9a" id="5e9a" class="graf graf--p graf-after--p">Rust doesn’t use traditional classes or inheritance like C++ or Python. Instead, everything is explicit. This struct contains only what the filter needs — and thanks to Rust’s strong typing, every field is guaranteed to be valid, initialized, and immutable unless explicitly marked otherwise.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="bdfd" id="bdfd" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">// EKF Struct</span><br /><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">EKF</span> {<br />    <span class="hljs-keyword">pub</span> state: Vector7,                 <span class="hljs-comment">// State vector: [q0, q1, q2, q3, bx, by, bz]</span><br />    <span class="hljs-keyword">pub</span> covariance: Matrix7,            <span class="hljs-comment">// Covariance matrix P</span><br />    <span class="hljs-keyword">pub</span> process_noise: Matrix7,         <span class="hljs-comment">// Process noise Q</span><br />    <span class="hljs-keyword">pub</span> measurement_noise: Matrix3,     <span class="hljs-comment">// Measurement noise R</span><br />}</span></pre><p name="8a1b" id="8a1b" class="graf graf--p graf-after--pre">By designing the EKF this way, the states are co-located in one place. There’s no global state, no hidden dependencies, and everything is initialized upfront — which is a huge advantage when integrating into larger ROS2 systems. The struct components are:</p><ul class="postList"><li name="d6c6" id="d6c6" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">State Vector (</strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">state</strong></code><strong class="markup--strong markup--li-strong">)</strong>: Tracks the system&#39;s state, including the quaternion and gyro bias.</li><li name="91bf" id="91bf" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Covariance Matrix (</strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">covariance</strong></code><strong class="markup--strong markup--li-strong">)</strong>: Represents the uncertainty of the state estimate.</li><li name="d906" id="d906" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Process Noise (</strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">process_noise</strong></code><strong class="markup--strong markup--li-strong">)</strong>: A matrix representing system noise (Q), tuned for the specific dynamics of the system.</li><li name="9810" id="9810" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Measurement Noise (</strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">measurement_noise</strong></code><strong class="markup--strong markup--li-strong">)</strong>: A matrix representing sensor noise (R), also tuned experimentally.</li></ul><h3 name="f883" id="f883" class="graf graf--h3 graf-after--li">5.3 Initializing the Filter</h3><p name="a002" id="a002" class="graf graf--p graf-after--h3">The new() method creates a fresh EKF instance. And like everything in Rust, initialization is explicit and safe — no uninitialized memory, no None-filled placeholders. If it compiles, it runs.</p><p name="35d1" id="35d1" class="graf graf--p graf-after--p">There’s an important design choice here: I give the constructor the option to take an initial accelerometer reading and use it to estimate the initial quaternion. This avoids the awkward spin-up time you’d get from starting at an identity quaternion and waiting for the filter to converge. In practice, it’s very common for drones to startup not in a perfect identity matrix orientation. For example, race drones usually start on their sides for optimal launches at the start of a race. While my drone will likely never be used for racing, (not that it’d be competitive anyway) it’s still a good practice in robotics determine the initial orientation as best you can rather than feeding an arbitrary state and waiting for the filter to converge to the true initial state.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="ae2a" id="ae2a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">EKF</span> {<br />    <span class="hljs-comment">/// Create a new EKF instance, passing accelerometer data to calculate the initial quaternion (avoids using 0&#x27;s for initial orientation)</span><br />    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(accel_data: <span class="hljs-type">Option</span>&lt;[<span class="hljs-type">f64</span>; <span class="hljs-number">3</span>]&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> {<br />        <span class="hljs-keyword">let</span> (q0, q1, q2, q3) = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(accel_data) = accel_data {<br />            <span class="hljs-comment">// Normalize acceleroHardware-in-the-Loop (HITL) Testingmeter vector</span><br />            <span class="hljs-keyword">let</span> <span class="hljs-variable">norm</span> = (accel_data[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">powi</span>(<span class="hljs-number">2</span>) + accel_data[<span class="hljs-number">1</span>].<span class="hljs-title function_ invoke__">powi</span>(<span class="hljs-number">2</span>) + accel_data[<span class="hljs-number">2</span>].<span class="hljs-title function_ invoke__">powi</span>(<span class="hljs-number">2</span>)).<span class="hljs-title function_ invoke__">sqrt</span>();<br />            <span class="hljs-keyword">let</span> <span class="hljs-variable">ax</span> = accel_data[<span class="hljs-number">0</span>] / norm;<br />            <span class="hljs-keyword">let</span> <span class="hljs-variable">ay</span> = accel_data[<span class="hljs-number">1</span>] / norm;<br />            <span class="hljs-keyword">let</span> <span class="hljs-variable">az</span> = -accel_data[<span class="hljs-number">2</span>] / norm;<br /><br />            <span class="hljs-comment">// Calculate quaternion from accelerometer data</span><br />            <span class="hljs-keyword">let</span> <span class="hljs-variable">q0</span> = (<span class="hljs-number">1.0</span> + az).<span class="hljs-title function_ invoke__">sqrt</span>() / <span class="hljs-number">2.0</span>;<br />            <span class="hljs-keyword">let</span> <span class="hljs-variable">q1</span> = -ay / (<span class="hljs-number">2.0</span> * q0);<br />            <span class="hljs-keyword">let</span> <span class="hljs-variable">q2</span> = ax / (<span class="hljs-number">2.0</span> * q0);<br />            <span class="hljs-keyword">let</span> <span class="hljs-variable">q3</span>: <span class="hljs-type">f64</span> = <span class="hljs-number">0.0</span>; <span class="hljs-comment">// Yaw is zero since accelerometer data cannot calculate yaw angles</span><br /><br />            <span class="hljs-keyword">let</span> <span class="hljs-variable">norm</span> = (q0.<span class="hljs-title function_ invoke__">powi</span>(<span class="hljs-number">2</span>) + q1.<span class="hljs-title function_ invoke__">powi</span>(<span class="hljs-number">2</span>) + q2.<span class="hljs-title function_ invoke__">powi</span>(<span class="hljs-number">2</span>) + q3.<span class="hljs-title function_ invoke__">powi</span>(<span class="hljs-number">2</span>)).<span class="hljs-title function_ invoke__">sqrt</span>();<br />            <span class="hljs-keyword">let</span> <span class="hljs-variable">q0</span> = q0 / norm;<br />            <span class="hljs-keyword">let</span> <span class="hljs-variable">q1</span> = q1 / norm;<br />            <span class="hljs-keyword">let</span> <span class="hljs-variable">q2</span> = q2 / norm;<br />            <span class="hljs-keyword">let</span> <span class="hljs-variable">q3</span> = q3 / norm;<br /><br />            (q0, q1, q2, q3)<br />        } <span class="hljs-keyword">else</span> {<br />            <span class="hljs-comment">// Default to identity quaternion</span><br />            (<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>)<br />        };</span></pre><p name="008f" id="008f" class="graf graf--p graf-after--pre">If no data is passed, it defaults to the identity quaternion. But if a valid accel vector is provided, we normalize it and use it to calculate roll and pitch based on gravity — then build a quaternion that starts the EKF off closer to the truth. Yaw can’t be resolved from the accelerometer alone, so we initialize it to zero and let it drift until a magnetometer or SLAM system is integrated later.</p><h3 name="b4ed" id="b4ed" class="graf graf--h3 graf-after--p">5.4 Noise Matrices and Tuning</h3><p name="38c9" id="38c9" class="graf graf--p graf-after--h3">Inside new(), we also initialize the process noise matrix Q and the measurement noise matrix R.</p><p name="245c" id="245c" class="graf graf--p graf-after--p">These matrices are key to how the EKF balances trust between the dynamics model and the incoming sensor data. In this implementation, I chose diagonal matrices with small nonzero values — easy to tune experimentally, and easy to reason about when debugging filter performance.</p><p name="0e72" id="0e72" class="graf graf--p graf-after--p">They’re declared explicitly so tuning becomes a guided process — not a scavenger hunt through implicit defaults. When testing the performance of the EKF you will be altering these matrices and observing performance. Once they’re set here they are static and do not change throughout the EKF process.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="9e41" id="9e41" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">        <span class="hljs-comment">// Initialize process and measurement noise matrices</span><br />        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">process_noise</span> = Matrix7::<span class="hljs-title function_ invoke__">zeros</span>();<br />        process_noise[(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)] = <span class="hljs-number">0.001</span>; <span class="hljs-comment">// q0</span><br />        process_noise[(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)] = <span class="hljs-number">0.001</span>; <span class="hljs-comment">// q1</span><br />        process_noise[(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)] = <span class="hljs-number">0.001</span>; <span class="hljs-comment">// q2</span><br />        process_noise[(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)] = <span class="hljs-number">0.001</span>; <span class="hljs-comment">// q3</span><br />        process_noise[(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)] = <span class="hljs-number">0.0</span>; <span class="hljs-comment">// bx</span><br />        process_noise[(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)] = <span class="hljs-number">0.0</span>; <span class="hljs-comment">// by</span><br />        process_noise[(<span class="hljs-number">6</span>, <span class="hljs-number">6</span>)] = <span class="hljs-number">0.0</span>; <span class="hljs-comment">// bz</span><br />        <br />        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">measurement_noise</span> = Matrix3::<span class="hljs-title function_ invoke__">zeros</span>();<br />        measurement_noise[(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)] = <span class="hljs-number">0.03</span>; <span class="hljs-comment">// accel x</span><br />        measurement_noise[(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)] = <span class="hljs-number">0.03</span>; <span class="hljs-comment">// accel y</span><br />        measurement_noise[(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)] = <span class="hljs-number">0.03</span>; <span class="hljs-comment">// accel z </span></span></pre><h3 name="c673" id="c673" class="graf graf--h3 graf-after--pre">5.5 Initialization Wrap-Up</h3><p name="dce2" id="dce2" class="graf graf--p graf-after--h3">Now we can return the EKF instance with the initial quaternion, 0 placeholders for the gyro bias, and the remaining EKF matrices:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="rust" name="7d43" id="7d43" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">EKF {<br />        state: {<br />            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">state</span> = Vector7::<span class="hljs-title function_ invoke__">zeros</span>();<br />            state[<span class="hljs-number">0</span>] = q0;<br />            state[<span class="hljs-number">1</span>] = q1;<br />            state[<span class="hljs-number">2</span>] = q2;<br />            state[<span class="hljs-number">3</span>] = q3;<br />            state[<span class="hljs-number">4</span>] = <span class="hljs-number">0.0</span>; <span class="hljs-comment">// bx</span><br />            state[<span class="hljs-number">5</span>] = <span class="hljs-number">0.0</span>; <span class="hljs-comment">// by</span><br />            state[<span class="hljs-number">6</span>] = <span class="hljs-number">0.0</span>; <span class="hljs-comment">// bz</span><br />            state<br />        },<br />        covariance: Matrix7::<span class="hljs-title function_ invoke__">identity</span>() * <span class="hljs-number">1.0</span>, <span class="hljs-comment">// Initial state covariance</span><br />        process_noise,<br />        measurement_noise,<br />    }<br />}</span></pre><ul class="postList"><li name="e441" id="e441" class="graf graf--li graf-after--pre"><strong class="markup--strong markup--li-strong">State Vector (</strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">state</strong></code><strong class="markup--strong markup--li-strong">)</strong>:<br>The state vector starts with a quaternion derived from accelerometer data, giving the filter a solid first guess at orientation. This vector represents the initial &quot;assumed&quot; state of the system. The state vector is dynamic, meaning it will be updated in every iteration of the EKF to reflect the estimated system state.</li><li name="e102" id="e102" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Covariance Matrix (</strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">covariance</strong></code><strong class="markup--strong markup--li-strong">)</strong>:<br>The covariance matrix is initialized as an identity matrix, scaled by a magnitude of <code class="markup--code markup--li-code">1.0</code>. This represents initial uncertainty in the state estimation. Like the state vector, the covariance matrix is dynamic and evolves with each EKF iteration based on the prediction and update steps. 1.0 is an arbitrary uncertainty.</li><li name="6ccb" id="6ccb" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Process Noise Matrix (</strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">process_noise</strong></code><strong class="markup--strong markup--li-strong">)</strong>:<br>The process noise matrix (<code class="markup--code markup--li-code">Q</code>) accounts for uncertainty or errors in the system dynamics model. It is initialized as an identity matrix with indices scaled by some experimentally tuned values. It remains static during EKF iterations.</li><li name="07c2" id="07c2" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Measurement Noise Matrix (</strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">measurement_noise</strong></code><strong class="markup--strong markup--li-strong">)</strong>:<br>The measurement noise matrix (<code class="markup--code markup--li-code">R</code>) accounts for noise or errors in the sensor data. It is initialized as an identity matrix with indices scaled by some experimentally tuned values. Like <code class="markup--code markup--li-code">Q</code>, it remains static during EKF iterations.</li></ul><p name="596a" id="596a" class="graf graf--p graf-after--li">The <code class="markup--code markup--p-code">new</code> method ensures that all fields of the EKF struct are properly initialized with starting values. This approach centralizes the initialization logic, ensuring consistency and reducing errors when creating new EKF instances. It also makes the EKF flexible for modifications, such as tuning the noise matrices (<code class="markup--code markup--p-code">Q</code> and <code class="markup--code markup--p-code">R</code>).</p><p name="806c" id="806c" class="graf graf--p graf-after--p">This constructor reflects Rust’s strong emphasis on safety and correctness by requiring explicit initialization for all fields, ensuring the EKF starts with well-defined values.</p><figure name="a14f" id="a14f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*SGW6FHcHaQF_EQex" data-width="1125" data-height="750" src="https://cdn-images-1.medium.com/max/800/0*SGW6FHcHaQF_EQex"><figcaption class="imageCaption"><em class="markup--em markup--figure-em">Photo by </em><a href="https://www.pexels.com/@joshsorenson/" data-href="https://www.pexels.com/@joshsorenson/" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank"><em class="markup--em markup--figure-em">Josh Sorenson</em></a><em class="markup--em markup--figure-em"> on </em><a href="https://www.pexels.com/photo/white-drone-2044044/" data-href="https://www.pexels.com/photo/white-drone-2044044/" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank"><em class="markup--em markup--figure-em">Pexels</em></a></figcaption></figure><h3 name="ca56" id="ca56" class="graf graf--h3 graf-after--figure">6. The Extended Kalman Filter</h3><p name="78b2" id="78b2" class="graf graf--p graf-after--h3">The Extended Kalman Filter (EKF) consists of two main phases: the <strong class="markup--strong markup--p-strong">Prediction Phase</strong> and the <strong class="markup--strong markup--p-strong">Update Phase</strong>. Each phase plays a critical role in estimating the state of the system (in this case, the quadcopter’s attitude) by combining dynamic modeling and sensor measurements. Below is a high-level outline of the steps in each phase. Subsequent sections will provide detailed explanations of these steps, including both the theoretical basis and practical implementation in Rust.</p><h3 name="02a7" id="02a7" class="graf graf--h3 graf-after--p">Prediction Phase</h3><p name="ca6a" id="ca6a" class="graf graf--p graf-after--h3">The <strong class="markup--strong markup--p-strong">Prediction Phase</strong> uses the system’s dynamics and gyroscope input to estimate the next state of the system and the associated uncertainty. This phase is driven by the dynamic model of the system.</p><ol class="postList"><li name="911b" id="911b" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Compute the Dynamic Model, f(x, u):</strong><br>Use the system’s dynamics to calculate how the state evolves over time, based on the previous state and control inputs (if any). This accounts for how the quadcopter’s attitude changes based on gyroscope readings.</li><li name="afe4" id="afe4" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Update the State Vector:</strong><br>Use the computed dynamic model to update the state vector, which represents the system’s estimated attitude and gyroscope bias.</li><li name="eedb" id="eedb" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Calculate the Dynamics Jacobian:</strong><br>Derive the partial derivatives of the dynamic model with respect to the state vector to compute the dynamics Jacobian matrix, which captures how small changes in the state affect the dynamics.</li><li name="c37b" id="c37b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Update the Covariance Matrix:</strong><br>Use the dynamics Jacobian and the process noise matrix (Q) to update the covariance matrix, which represents the uncertainty in the state estimation.</li></ol><h3 name="f0d3" id="f0d3" class="graf graf--h3 graf-after--li">Update Phase</h3><p name="a196" id="a196" class="graf graf--p graf-after--h3">The <strong class="markup--strong markup--p-strong">Update Phase</strong> incorporates sensor measurements (in this case, accelerometer data) to correct the predicted state and reduce uncertainty. This phase ensures long-term accuracy by counteracting drift in the gyroscope’s estimates.</p><ol class="postList"><li name="8ac7" id="8ac7" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Compute the Measurement Model, h(x, u):</strong><br>Use the measurement model to predict what the sensor measurements should be based on the current state estimate.</li><li name="948f" id="948f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Compute the Innovation:</strong><br>Calculate the difference between the actual sensor measurements and the predicted measurements from the measurement model. This difference, known as the innovation or residual, tells us how far off our prediction was — and how much the state estimate needs to shift to match the real world.</li><li name="b414" id="b414" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Compute the Measurement Jacobian:</strong><br>Derive the partial derivatives of the measurement model with respect to the state vector to compute the measurement Jacobian matrix, which captures how the state affects the sensor measurements.</li><li name="27aa" id="27aa" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Compute the Innovation Covariance:</strong><br>Use the measurement Jacobian, covariance matrix, and measurement noise matrix R to compute the innovation covariance, which represents the uncertainty in the innovation.</li><li name="e803" id="e803" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Compute the Kalman Gain, K:</strong><br>Calculate the Kalman Gain, which balances the trust between the predicted state and the sensor measurements when updating the state. (i.e. how much should we trust the sensor versus our prediction?)</li><li name="ca4a" id="ca4a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Update the State Vector:</strong><br>Use the Kalman Gain and the innovation to update the state vector, correcting the predicted state using the sensor measurements.</li><li name="dab6" id="dab6" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Update the Covariance Matrix:</strong><br>Use the Kalman Gain and the measurement Jacobian to update the covariance matrix, reducing uncertainty in the corrected state estimate.</li></ol><p name="3c58" id="3c58" class="graf graf--p graf-after--li">This structure outlines the logical flow of the EKF and highlights the roles of the dynamic and measurement models, as well as the iterative process of combining predictions with sensor corrections. Each step ensures that the system state estimate is as accurate as possible while accounting for uncertainty in both the system’s dynamics and the sensor data.</p><h3 name="bad5" id="bad5" class="graf graf--h3 graf-after--p">6.1 Prediction Phase</h3><p name="04e4" id="04e4" class="graf graf--p graf-after--h3">The <strong class="markup--strong markup--p-strong">Prediction Phase</strong> estimates the system’s next state based on the current state and the system’s dynamics. In our implementation, this entire phase is encapsulated in the <code class="markup--code markup--p-code">predict</code> method. This method computes the dynamic model, updates the state vector, and calculates the dynamics Jacobian and covariance matrix.</p><h3 name="bad2" id="bad2" class="graf graf--h3 graf-after--p">Declaring the Predict Method</h3><p name="5da8" id="5da8" class="graf graf--p graf-after--h3">We start by creating the <code class="markup--code markup--p-code">predict</code> method and declaring it as public using <code class="markup--code markup--p-code">pub fn</code>. The method takes 2 arguments <code class="markup--code markup--p-code">gyro</code>, which is an array of size 3 (<code class="markup--code markup--p-code">[f64; 3]</code>) containing gyroscope data for the x, y, and z axes in units of rad/s (angular velocities) and <code class="markup--code markup--p-code">dt</code> which is the timestep in seconds. The time step can be constant if you can guarantee that the system is operating at a constant frequency. For real-world systems, it becomes difficult to guarantee a global frequency. For that reason, we calculate the timestep dynamically and feed the exact time that has passed since the last cycle to the EKF for precise calculation.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="a5a0" id="a5a0" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">predict</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, gyro: [<span class="hljs-type">f64</span>; <span class="hljs-number">3</span>], dt: <span class="hljs-type">f64</span>) {</span></pre><h3 name="bdd7" id="bdd7" class="graf graf--h3 graf-after--pre">6.1.1 Compute the Dynamic Model: f(x, u)</h3><p name="e7ba" id="e7ba" class="graf graf--p graf-after--h3">The dynamic model, f(x,u), describes how the state evolves over time based on the system’s dynamics. In the case of the quadcopter, it predicts the quaternion using gyroscope data and the previously estimated quaternion. This nonlinear propagation model ensures that the state vector reflects realistic dynamics.</p><h4 name="5d14" id="5d14" class="graf graf--h4 graf-after--p">Dynamic Model Equations</h4><p name="2fa8" id="2fa8" class="graf graf--p graf-after--h4">The dynamic model uses the following equations for quaternion estimation:</p><figure name="1110" id="1110" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*p0L3lOSv53WfNZbp7R5hdg.png" data-width="1167" data-height="571" src="https://cdn-images-1.medium.com/max/800/1*p0L3lOSv53WfNZbp7R5hdg.png"></figure><p name="be11" id="be11" class="graf graf--p graf-after--figure">The quaternion is integrated over time using the gyroscope data, normalized to ensure it remains a valid unit quaternion.</p><h4 name="80b5" id="80b5" class="graf graf--h4 graf-after--p">Code Implementation</h4><p name="aeaf" id="aeaf" class="graf graf--p graf-after--h4">The Rust implementation of the dynamic model is as follows:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="089d" id="089d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">        <span class="hljs-comment">// 1. Subtract estimated bias from raw gyro measurements (control input)</span><br />        <span class="hljs-keyword">let</span> <span class="hljs-variable">bias</span> = <span class="hljs-keyword">self</span>.state.fixed_rows::&lt;<span class="hljs-number">3</span>&gt;(<span class="hljs-number">4</span>).<span class="hljs-title function_ invoke__">clone_owned</span>(); <span class="hljs-comment">// [bx, by, bz]</span><br />        <span class="hljs-keyword">let</span> <span class="hljs-variable">omega</span> = Vector3::<span class="hljs-title function_ invoke__">new</span>(gyro[<span class="hljs-number">0</span>], gyro[<span class="hljs-number">1</span>], gyro[<span class="hljs-number">2</span>]) - bias;<br /><br />        <span class="hljs-comment">// 2. Integrate quaternion using angular velocity (q̇ = 0.5 * Ω(ω) * q)</span><br />        <span class="hljs-keyword">let</span> <span class="hljs-variable">q</span> = Vector4::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">self</span>.state[<span class="hljs-number">0</span>], <span class="hljs-keyword">self</span>.state[<span class="hljs-number">1</span>], <span class="hljs-keyword">self</span>.state[<span class="hljs-number">2</span>], <span class="hljs-keyword">self</span>.state[<span class="hljs-number">3</span>]);<br />        <span class="hljs-keyword">let</span> <span class="hljs-variable">omega_matrix</span> = <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">omega_matrix</span>(omega);<br />        <span class="hljs-keyword">let</span> <span class="hljs-variable">q_dot</span> = <span class="hljs-number">0.5</span> * omega_matrix * q;<br />        <span class="hljs-keyword">let</span> <span class="hljs-variable">q_new</span> = q + q_dot * dt;<br /><br />        <span class="hljs-comment">// 3. Update state with new quaternion</span><br />        <span class="hljs-keyword">self</span>.state.fixed_rows_mut::&lt;<span class="hljs-number">4</span>&gt;(<span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">copy_from</span>(&amp;q_new);<br />        <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">normalize_quaternion_in_state</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.state);</span></pre><h4 name="dc2a" id="dc2a" class="graf graf--h4 graf-after--pre">Explanation of the Code</h4><ol class="postList"><li name="c6cf" id="c6cf" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">bias</strong>: Estimated gyro bias</li><li name="b28e" id="b28e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">omega</strong>: Gyro data vector using angular velocities around each axis</li><li name="3438" id="3438" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">q</strong>: The current quaternion, extracted from the state vector.</li><li name="3a32" id="3a32" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">State Vector Update</strong>: The state vector is updated with the predicted quaternion and the most recent gyroscope data.</li><li name="eae4" id="eae4" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Normalization</strong>: Quaternions must always be normalized to account for small accumulating errors.</li></ol><p name="a352" id="a352" class="graf graf--p graf-after--li">This step computes the dynamic evolution of the state vector using only gyroscope data and the dynamic model. In subsequent steps, this model’s output will be used to update the state vector and the covariance matrix. Each component of the state vector is updated iteratively during this step based on the dynamic model.</p><h3 name="d641" id="d641" class="graf graf--h3 graf-after--p">6.1.2 Compute the Dynamic Jacobian</h3><p name="2026" id="2026" class="graf graf--p graf-after--h3">The <strong class="markup--strong markup--p-strong">Dynamic Jacobian</strong> (∂f/∂x​) is a first-order linear approximation that quantifies how the state vector components influence each other in a nonlinear dynamic system. It is a matrix of partial derivatives, where each element represents the sensitivity of one state variable’s rate of change to changes in another state variable.</p><h4 name="edbc" id="edbc" class="graf graf--h4 graf-after--p">The Jacobian Matrix</h4><p name="08be" id="08be" class="graf graf--p graf-after--h4">For a state vector of size <code class="markup--code markup--p-code">n</code>, the Jacobian is an <code class="markup--code markup--p-code">n×n</code> matrix. Each row contains the <strong class="markup--strong markup--p-strong">partial derivatives of the time derivative of one state variable with respect to all components of the state vector.</strong></p><p name="97ea" id="97ea" class="graf graf--p graf-after--p">Below is the Jacobian Matrix:</p><figure name="3bc5" id="3bc5" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*EJcxmCcNI_avIQ_nT8gHjQ.png" data-width="1202" data-height="653" src="https://cdn-images-1.medium.com/max/800/1*EJcxmCcNI_avIQ_nT8gHjQ.png"></figure><p name="9169" id="9169" class="graf graf--p graf-after--figure">Code Implementation</p><p name="a54e" id="a54e" class="graf graf--p graf-after--p">In the code, we compute the Jacobian manually in the <code class="markup--code markup--p-code">compute_f_jacobian</code> function. It accepts gyroscope data and a timestep, <code class="markup--code markup--p-code">dt</code> and returns the matrix ∂f/∂x based on the quaternion propagation model.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="ef15" id="ef15" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">        <span class="hljs-comment">// 4. Compute Jacobian of motion model (F = ∂f/∂x)</span><br />        <span class="hljs-keyword">let</span> <span class="hljs-variable">f_jacobian</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">compute_f_jacobian</span>(gyro, dt);</span></pre><p name="5ad8" id="5ad8" class="graf graf--p graf-after--pre">Here’s the <code class="markup--code markup--p-code">compute_f_jacobian</code> method:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="bf9d" id="bf9d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-comment">/// Compute the dynamic Jacobian (∂f/∂x)</span><br />    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">compute_f_jacobian</span>(&amp;<span class="hljs-keyword">self</span>, gyro: [<span class="hljs-type">f64</span>; <span class="hljs-number">3</span>], dt: <span class="hljs-type">f64</span>) <span class="hljs-punctuation">-&gt;</span> Matrix7 {<br />        <span class="hljs-keyword">let</span> <span class="hljs-variable">q0</span> = <span class="hljs-keyword">self</span>.state[<span class="hljs-number">0</span>];<br />        <span class="hljs-keyword">let</span> <span class="hljs-variable">q1</span> = <span class="hljs-keyword">self</span>.state[<span class="hljs-number">1</span>];<br />        <span class="hljs-keyword">let</span> <span class="hljs-variable">q2</span> = <span class="hljs-keyword">self</span>.state[<span class="hljs-number">2</span>];<br />        <span class="hljs-keyword">let</span> <span class="hljs-variable">q3</span> = <span class="hljs-keyword">self</span>.state[<span class="hljs-number">3</span>];<br />        <span class="hljs-keyword">let</span> <span class="hljs-variable">bx</span> = <span class="hljs-keyword">self</span>.state[<span class="hljs-number">4</span>];<br />        <span class="hljs-keyword">let</span> <span class="hljs-variable">by</span> = <span class="hljs-keyword">self</span>.state[<span class="hljs-number">5</span>];<br />        <span class="hljs-keyword">let</span> <span class="hljs-variable">bz</span> = <span class="hljs-keyword">self</span>.state[<span class="hljs-number">6</span>];<br /><br />        <span class="hljs-keyword">let</span> <span class="hljs-variable">p</span> = gyro[<span class="hljs-number">0</span>] - bx;<br />        <span class="hljs-keyword">let</span> <span class="hljs-variable">q</span> = gyro[<span class="hljs-number">1</span>] - by;<br />        <span class="hljs-keyword">let</span> <span class="hljs-variable">r</span> = gyro[<span class="hljs-number">2</span>] - bz;<br /><br />        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = Matrix7::<span class="hljs-title function_ invoke__">identity</span>();<br /><br />        <span class="hljs-comment">// Quaternion dynamics wrt quaternion</span><br />        f[(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)] = -p * dt;<br />        f[(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)] = -q * dt;<br />        f[(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)] = -r * dt;<br /><br />        f[(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)] =  p * dt;<br />        f[(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)] =  r * dt;<br />        f[(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)] = -q * dt;<br /><br />        f[(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)] =  q * dt;<br />        f[(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)] = -r * dt;<br />        f[(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)] =  p * dt;<br /><br />        f[(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>)] =  r * dt;<br />        f[(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)] =  q * dt;<br />        f[(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>)] = -p * dt;<br /><br />        <span class="hljs-comment">// Quaternion dynamics wrt bias</span><br />        f[(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>)] =  <span class="hljs-number">0.5</span> * q1 * dt;<br />        f[(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)] =  <span class="hljs-number">0.5</span> * q2 * dt;<br />        f[(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>)] =  <span class="hljs-number">0.5</span> * q3 * dt;<br /><br />        f[(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)] = -<span class="hljs-number">0.5</span> * q0 * dt;<br />        f[(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)] = -<span class="hljs-number">0.5</span> * q3 * dt;<br />        f[(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)] =  <span class="hljs-number">0.5</span> * q2 * dt;<br /><br />        f[(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)] =  <span class="hljs-number">0.5</span> * q3 * dt;<br />        f[(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)] = -<span class="hljs-number">0.5</span> * q0 * dt;<br />        f[(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>)] = -<span class="hljs-number">0.5</span> * q1 * dt;<br /><br />        f[(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)] = -<span class="hljs-number">0.5</span> * q2 * dt;<br />        f[(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)] =  <span class="hljs-number">0.5</span> * q1 * dt;<br />        f[(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)] = -<span class="hljs-number">0.5</span> * q0 * dt;<br /><br />        f<br />    }</span></pre><h3 name="a4d4" id="a4d4" class="graf graf--h3 graf-after--pre">6.1.3 Update the Covariance Matrix</h3><p name="44e5" id="44e5" class="graf graf--p graf-after--h3">The final step in the <strong class="markup--strong markup--p-strong">Prediction Phase</strong> is updating the <strong class="markup--strong markup--p-strong">Covariance Matrix</strong>, which quantifies the uncertainty in the state estimate. This update accounts for how the system dynamics and process noise affect the uncertainty as the system evolves. The mathematical equation for this step is:</p><figure name="a519" id="a519" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*dUpNlflKL3RopL6_hVaRYQ.png" data-width="788" data-height="161" src="https://cdn-images-1.medium.com/max/800/1*dUpNlflKL3RopL6_hVaRYQ.png"></figure><p name="e520" id="e520" class="graf graf--p graf-after--figure">where:</p><ul class="postList"><li name="5376" id="5376" class="graf graf--li graf-after--p">P: The covariance matrix, which was initialized as an identity matrix with some magnitude during the EKF initialization.</li><li name="aa34" id="aa34" class="graf graf--li graf-after--li">Tout/N: The time step (dt).</li><li name="4c6a" id="4c6a" class="graf graf--li graf-after--li">A: The Jacobian matrix of the dynamics, (sometimes F is used) calculated earlier in the <strong class="markup--strong markup--li-strong">Compute the Dynamic Jacobian</strong> step.</li><li name="ea6e" id="ea6e" class="graf graf--li graf-after--li">Q: The process noise matrix, initialized during the EKF instance creation (<code class="markup--code markup--li-code">impl</code> code block). Remember that <strong class="markup--strong markup--li-strong">the process noise matrix Q must be tuned experimentally</strong> to appropriately reflect the noise in the system dynamics.</li></ul><p name="7e23" id="7e23" class="graf graf--p graf-after--li">Note: The process noise matrix <code class="markup--code markup--p-code">Q</code> must be tuned experimentally to reflect the true uncertainty in the system’s dynamics.</p><h4 name="a728" id="a728" class="graf graf--h4 graf-after--p">Explanation</h4><ul class="postList"><li name="3a8d" id="3a8d" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">Jacobian Matrix (A/F):</strong> Describes how the state evolves under the system’s dynamics. It’s used to propagate uncertainty through the nonlinear model <code class="markup--code markup--li-code">f(x,u)</code>.</li><li name="1452" id="1452" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Process Noise (Q):</strong> Represents external disturbances or modeling inaccuracies. Since the dynamic model isn’t perfect, <code class="markup--code markup--li-code">Q</code> helps account for those imperfections.</li><li name="7990" id="7990" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Time Step (dt):</strong> Scales the update to reflect how fast the system is evolving between iterations.</li></ul><p name="972f" id="972f" class="graf graf--p graf-after--li">The updated covariance matrix quantifies the propagated uncertainty in the state estimate after considering how the dynamics model evolves the state.</p><h4 name="11d5" id="11d5" class="graf graf--h4 graf-after--p">Code Implementation</h4><p name="ca60" id="ca60" class="graf graf--p graf-after--h4">The corresponding Rust code for updating the covariance matrix is:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="rust" name="6247" id="6247" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">        <span class="hljs-comment">// 5. Propagate uncertainty using the covariance update: P&#x27; = FPFᵀ + Q</span><br />        <span class="hljs-keyword">self</span>.covariance = f_jacobian * <span class="hljs-keyword">self</span>.covariance * f_jacobian.<span class="hljs-title function_ invoke__">transpose</span>() + <span class="hljs-keyword">self</span>.process_noise;</span></pre><p name="3561" id="3561" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Matrix Operations</strong>:</p><ul class="postList"><li name="ac96" id="ac96" class="graf graf--li graf-after--p">FPFᵀ: Propagates the previous covariance through the dynamics via the Jacobian.</li><li name="92ed" id="92ed" class="graf graf--li graf-after--li">Q: Adds modeled uncertainty from system noise.</li><li name="1fb2" id="1fb2" class="graf graf--li graf-after--li">dt: The time step scales the entire expression.</li></ul><p name="acc9" id="acc9" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Initialization</strong>:</p><ul class="postList"><li name="8312" id="8312" class="graf graf--li graf-after--p">For the first iteration, the covariance matrix P is initialized to an identity matrix scaled by 1.0.</li></ul><p name="7360" id="7360" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">Dynamic Update</strong>:</p><ul class="postList"><li name="54b8" id="54b8" class="graf graf--li graf-after--p">On each prediction step, the updated <code class="markup--code markup--li-code">P</code> reflects current uncertainty based on system dynamics and sensor trust.</li></ul><h4 name="1fb1" id="1fb1" class="graf graf--h4 graf-after--li">Key Notes</h4><ul class="postList"><li name="3b40" id="3b40" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">Importance of Tuning Q:</strong> If <code class="markup--code markup--li-code">Q</code> is too small, the filter will trust the model too much — potentially ignoring real-world disturbances. If <code class="markup--code markup--li-code">Q</code> is too large, the filter will assume too much uncertainty and converge too slowly or erratically. Finding the right balance is part of the art of EKF tuning.</li><li name="75dc" id="75dc" class="graf graf--li graf-after--li">This step ensures that the EKF carries forward not just the predicted state, but also an honest accounting of how confident it is in that state — a key strength of Kalman-based estimation.</li></ul><h3 name="1b77" id="1b77" class="graf graf--h3 graf-after--li">6.2 Update Phase</h3><p name="da95" id="da95" class="graf graf--p graf-after--h3">The <strong class="markup--strong markup--p-strong">Update Phase</strong> refines the predicted state estimate by incorporating actual sensor readings. This is where the EKF “corrects” its prior estimate from the <strong class="markup--strong markup--p-strong">Prediction Phase</strong> by comparing expected sensor measurements (via the measurement model h(x,u)) with the actual measurements coming from the accelerometer.</p><p name="ea9b" id="ea9b" class="graf graf--p graf-after--p">The entire phase is encapsulated in the <code class="markup--code markup--p-code">update</code> method.</p><p name="f2ee" id="f2ee" class="graf graf--p graf-after--p">At this point in the EKF, the <strong class="markup--strong markup--p-strong">state vector</strong> and <strong class="markup--strong markup--p-strong">covariance matrix</strong> have already been predicted using gyroscope data and the system’s dynamic model. The <strong class="markup--strong markup--p-strong">Update Phase</strong> now brings in accelerometer data to further refine the estimate, correcting drift and improving long-term accuracy.</p><h3 name="dbb8" id="dbb8" class="graf graf--h3 graf-after--p">6.2.1 Compute the Measurement Model: h(x,u)</h3><p name="e8d2" id="e8d2" class="graf graf--p graf-after--h3">The <strong class="markup--strong markup--p-strong">Measurement Model</strong> plays a role analogous to the <strong class="markup--strong markup--p-strong">Dynamics Model, f(x,u)</strong> used in the prediction phase — but instead of projecting the state forward in time, it projects the current state into sensor space. In other words:</p><ul class="postList"><li name="248e" id="248e" class="graf graf--li graf-after--p">The measurement model h(x,u) predicts what the sensors <strong class="markup--strong markup--li-strong">should</strong> measure, given the current state.</li><li name="086e" id="086e" class="graf graf--li graf-after--li">In this case, it uses the estimated quaternion to compute what the <strong class="markup--strong markup--li-strong">accelerometer</strong> would read under ideal conditions (i.e., gravity only, no linear acceleration).</li><li name="0b7f" id="0b7f" class="graf graf--li graf-after--li">This prediction is then compared to the actual accelerometer measurement to compute a correction.</li></ul><figure name="c4a3" id="c4a3" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*Dloi3eazL0yiqynEc6CpNg.png" data-width="584" data-height="95" src="https://cdn-images-1.medium.com/max/800/1*Dloi3eazL0yiqynEc6CpNg.png"></figure><h4 name="92e7" id="92e7" class="graf graf--h4 graf-after--figure">Explanation of Components:</h4><ol class="postList"><li name="547f" id="547f" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">Gravitational Vector (g)</strong>: The gravitational vector represents the direction and magnitude of gravity in the world frame (also called the inertial frame or global frame).</li><li name="3c9b" id="3c9b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Quaternion (q)</strong>: The quaternion <code class="markup--code markup--li-code">q=[w,x,y,z]</code> represents the orientation of the body (quadcopter) relative to the world frame. It encodes the rotation needed to transform vectors from the world frame to the body frame.</li><li name="2e11" id="2e11" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Rotation Matrix (R)</strong>: The rotation matrix <code class="markup--code markup--li-code">R</code> is a 3x3 matrix that transforms vectors from the world frame to the body frame. It is derived directly from the quaternion <code class="markup--code markup--li-code">q</code>.</li><li name="bf54" id="bf54" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Transpose of the Rotation Matrix</strong>: The transpose of the rotation matrix transforms vectors from the body frame back to the world frame. Since the accelerometer measures gravity in the body frame, we use the transpose of the rotation matrix to transform the gravitational vector from the world frame to the body frame.</li></ol><h4 name="0fe7" id="0fe7" class="graf graf--h4 graf-after--li">Code Implementation</h4><p name="5a0f" id="5a0f" class="graf graf--p graf-after--h4">Here’s the <code class="markup--code markup--p-code">update</code> method that calculates the predicted measurement and sets up for the correction step:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="7a23" id="7a23" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">/// EKF Update Step: Corrects the prediction using accelerometer data (gravity vector).</span><br /><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">update</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, accel: [<span class="hljs-type">f64</span>; <span class="hljs-number">3</span>]) {<br />    <span class="hljs-comment">// 1. Compute expected gravity vector in sensor frame (using estimated orientation)</span><br />    <span class="hljs-keyword">let</span> <span class="hljs-variable">gravity</span> = Vector3::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, -GRAVITY);<br />    <span class="hljs-keyword">let</span> <span class="hljs-variable">q</span> = Vector4::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-keyword">self</span>.state[<span class="hljs-number">0</span>], <span class="hljs-keyword">self</span>.state[<span class="hljs-number">1</span>], <span class="hljs-keyword">self</span>.state[<span class="hljs-number">2</span>], <span class="hljs-keyword">self</span>.state[<span class="hljs-number">3</span>]);<br />    <span class="hljs-keyword">let</span> <span class="hljs-variable">r_transpose</span> = <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">quaternion_to_rotation_matrix</span>(q).<span class="hljs-title function_ invoke__">transpose</span>();<br />    <span class="hljs-keyword">let</span> <span class="hljs-variable">accel_expected</span> = r_transpose * gravity;</span></pre><p name="64ec" id="64ec" class="graf graf--p graf-after--pre">And the <code class="markup--code markup--p-code">quaternion_to_rotation_matrix</code> method:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="rust" name="7839" id="7839" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">/// Convert quaternion to rotation matrix</span><br /><span class="hljs-keyword">fn</span> <span class="hljs-title function_">quaternion_to_rotation_matrix</span>(q: Vector4) <span class="hljs-punctuation">-&gt;</span> Matrix3 {<br />    <span class="hljs-keyword">let</span> <span class="hljs-variable">q0</span> = q[<span class="hljs-number">0</span>];<br />    <span class="hljs-keyword">let</span> <span class="hljs-variable">q1</span> = q[<span class="hljs-number">1</span>];<br />    <span class="hljs-keyword">let</span> <span class="hljs-variable">q2</span> = q[<span class="hljs-number">2</span>];<br />    <span class="hljs-keyword">let</span> <span class="hljs-variable">q3</span> = q[<span class="hljs-number">3</span>];<br /><br />    Matrix3::<span class="hljs-title function_ invoke__">new</span>(<br />        <span class="hljs-number">1.0</span> - <span class="hljs-number">2.0</span> * (q2 * q2 + q3 * q3),<br />        <span class="hljs-number">2.0</span> * (q1 * q2 - q0 * q3),<br />        <span class="hljs-number">2.0</span> * (q1 * q3 + q0 * q2),<br /><br />        <span class="hljs-number">2.0</span> * (q1 * q2 + q0 * q3),<br />        <span class="hljs-number">1.0</span> - <span class="hljs-number">2.0</span> * (q1 * q1 + q3 * q3),<br />        <span class="hljs-number">2.0</span> * (q2 * q3 - q0 * q1),<br /><br />        <span class="hljs-number">2.0</span> * (q1 * q3 - q0 * q2),<br />        <span class="hljs-number">2.0</span> * (q2 * q3 + q0 * q1),<br />        <span class="hljs-number">1.0</span> - <span class="hljs-number">2.0</span> * (q1 * q1 + q2 * q2),<br />    )<br />}</span></pre><h4 name="8425" id="8425" class="graf graf--h4 graf-after--pre">Summary</h4><p name="706f" id="706f" class="graf graf--p graf-after--h4">The measurement model transforms the global gravity vector into the body frame using the quaternion’s rotation matrix, producing a predicted accelerometer reading. The EKF then compares this with the actual accelerometer reading and uses the difference to adjust the orientation estimate.</p><p name="21be" id="21be" class="graf graf--p graf-after--p">This is the core of sensor fusion — blending fast, drifting gyroscope data with slow, stable accelerometer data to produce a high-fidelity estimate of real-world orientation.</p><h3 name="e24a" id="e24a" class="graf graf--h3 graf-after--p">6.2.2 Compute Innovation</h3><p name="95ae" id="95ae" class="graf graf--p graf-after--h3">The <strong class="markup--strong markup--p-strong">Innovation</strong> represents the difference between the actual sensor measurement (z) and the predicted measurement (h(x,u)), based on the current state estimate. It quantifies how far off the EKF’s prediction was from reality. Mathematically, this is expressed as:</p><figure name="f25d" id="f25d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*mvL2SXjSNTZvfwv04jPCwA.png" data-width="786" data-height="121" src="https://cdn-images-1.medium.com/max/800/1*mvL2SXjSNTZvfwv04jPCwA.png"></figure><p name="e56b" id="e56b" class="graf graf--p graf-after--figure">where:</p><ul class="postList"><li name="130a" id="130a" class="graf graf--li graf-after--p">y: Innovation (sometimes called the residual).</li><li name="36c3" id="36c3" class="graf graf--li graf-after--li">z: Actual sensor measurements from the accelerometer.</li><li name="8d4d" id="8d4d" class="graf graf--li graf-after--li">h(x,u): Predicted sensor measurements based on the current state and dynamics, computed using the measurement model.</li></ul><h4 name="b0bb" id="b0bb" class="graf graf--h4 graf-after--li">Purpose of Innovation</h4><p name="97b0" id="97b0" class="graf graf--p graf-after--h4">The innovation is a critical part of the <strong class="markup--strong markup--p-strong">Update Phase</strong> because it determines how much the filter corrects the predicted state:</p><ol class="postList"><li name="ebb3" id="ebb3" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Small Innovation</strong>: The predicted state is close to reality. The Kalman Gain will make only a slight correction.</li><li name="a143" id="a143" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Large Innovation</strong>: The prediction was off. The Kalman Gain will apply a stronger correction to bring the estimate back in line with the sensor data.</li></ol><p name="a1e4" id="a1e4" class="graf graf--p graf-after--li">The innovation directly influences the Kalman gain (K) and therefore determines how much weight the EKF assigns to the actual sensor measurements compared to the predicted state.</p><h4 name="77a0" id="77a0" class="graf graf--h4 graf-after--p">Code Implementation</h4><p name="2476" id="2476" class="graf graf--p graf-after--h4">Here’s how we compute the innovation in Rust:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="rust" name="869e" id="869e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-comment">// 2. Compute innovation (measurement residual): z - h(x)</span><br />    <span class="hljs-keyword">let</span> <span class="hljs-variable">z</span> = Vector3::<span class="hljs-title function_ invoke__">new</span>(accel[<span class="hljs-number">0</span>], accel[<span class="hljs-number">1</span>], accel[<span class="hljs-number">2</span>]);<br />    <span class="hljs-keyword">let</span> <span class="hljs-variable">innovation</span> = z - accel_expected;</span></pre><h3 name="5059" id="5059" class="graf graf--h3 graf-after--pre">6.2.3 Compute the Measurement Jacobian</h3><p name="606f" id="606f" class="graf graf--p graf-after--h3">The <strong class="markup--strong markup--p-strong">Measurement Jacobian (∂h/∂x​)</strong> is a 3×7 matrix that maps changes in the state vector to changes in the predicted accelerometer readings. Its components are derived from how small changes in the quaternion affect the predicted direction of gravity in the body frame — the key quantity compared to accelerometer data.</p><figure name="31b8" id="31b8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*fXoBgtbpA2fD0QHhioDYsA.png" data-width="907" data-height="216" src="https://cdn-images-1.medium.com/max/800/1*fXoBgtbpA2fD0QHhioDYsA.png"></figure><h4 name="3e29" id="3e29" class="graf graf--h4 graf-after--figure">Purpose of the Measurement Jacobian</h4><p name="3d7d" id="3d7d" class="graf graf--p graf-after--h4">The Jacobian is crucial for:</p><ol class="postList"><li name="0f7b" id="0f7b" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Calculating the Kalman Gain</strong>: Determines how much weight to assign to the actual measurement versus the predicted state during the update phase.</li><li name="f4a1" id="f4a1" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Propagating Measurement Information</strong>: Translates accelerometer measurement changes into state vector corrections, allowing the filter to refine its estimate.</li></ol><h4 name="39bb" id="39bb" class="graf graf--h4 graf-after--li">Code Implementation</h4><p name="ae18" id="ae18" class="graf graf--p graf-after--h4">Below is how the 3×7 Measurement Jacobian is computed in Rust, using quaternion elements and gravitational influence.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="62be" id="62be" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-comment">// 3. Compute Measurement Jacobian: H = ∂h/∂x</span><br />    <span class="hljs-keyword">let</span> <span class="hljs-variable">h_jacobian</span> = <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">compute_h_jacobian</span>(q);</span></pre><p name="27bb" id="27bb" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">compute_h_jacobian</code> method:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="rust" name="c3d3" id="c3d3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment">/// Compute the measurement Jacobian (∂h/∂x)</span><br /><span class="hljs-keyword">fn</span> <span class="hljs-title function_">compute_h_jacobian</span>(&amp;<span class="hljs-keyword">self</span>, q: Vector4) <span class="hljs-punctuation">-&gt;</span> Matrix3x7 {<br />    <span class="hljs-keyword">let</span> <span class="hljs-variable">q0</span> = q[<span class="hljs-number">0</span>];<br />    <span class="hljs-keyword">let</span> <span class="hljs-variable">q1</span> = q[<span class="hljs-number">1</span>];<br />    <span class="hljs-keyword">let</span> <span class="hljs-variable">q2</span> = q[<span class="hljs-number">2</span>];<br />    <span class="hljs-keyword">let</span> <span class="hljs-variable">q3</span> = q[<span class="hljs-number">3</span>];<br /><br />    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">h</span> = Matrix3x7::<span class="hljs-title function_ invoke__">zeros</span>();<br />    h[(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)] = <span class="hljs-number">2.0</span> * (-GRAVITY * q2);<br />    h[(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)] = <span class="hljs-number">2.0</span> * (GRAVITY * q3);<br />    h[(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)] = <span class="hljs-number">2.0</span> * (-GRAVITY * q0);<br />    h[(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)] = <span class="hljs-number">2.0</span> * (GRAVITY * q1);<br /><br />    h[(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)] = <span class="hljs-number">2.0</span> * (GRAVITY * q1);<br />    h[(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)] = <span class="hljs-number">2.0</span> * (GRAVITY * q0);<br />    h[(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)] = <span class="hljs-number">2.0</span> * (GRAVITY * q3);<br />    h[(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)] = <span class="hljs-number">2.0</span> * (GRAVITY * q2);<br /><br />    h[(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)] = <span class="hljs-number">2.0</span> * (GRAVITY * q0);<br />    h[(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)] = <span class="hljs-number">2.0</span> * (-GRAVITY * q1);<br />    h[(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)] = <span class="hljs-number">2.0</span> * (-GRAVITY * q2);<br />    h[(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)] = <span class="hljs-number">2.0</span> * (-GRAVITY * q3);<br /><br />    h<br />}</span></pre><h3 name="2556" id="2556" class="graf graf--h3 graf-after--pre">6.2.4 Compute the Innovation Covariance</h3><p name="b486" id="b486" class="graf graf--p graf-after--h3">The <strong class="markup--strong markup--p-strong">Innovation Covariance</strong> (S) quantifies the total uncertainty associated with the innovation vector (y) — that is, the difference between what the filter predicted and what the sensors actually observed. It does this by accounting for both:</p><ol class="postList"><li name="f6c8" id="f6c8" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Prediction Phase Uncertainty</strong>: Captured by the covariance matrix P, which reflects how uncertain the state prediction is.</li><li name="3bcf" id="3bcf" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Measurement Noise</strong>: Captured by the noise covariance matrix R, which represents the inherent noise in the sensor measurements.</li></ol><h4 name="766b" id="766b" class="graf graf--h4 graf-after--li">Purpose of the Innovation Covariance</h4><p name="1221" id="1221" class="graf graf--p graf-after--h4">The innovation covariance ensures the update phase incorporates measurement data in a statistically optimal way based on relative uncertainties:</p><ul class="postList"><li name="736b" id="736b" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Higher S</strong>: Means the EKF is less confident in the measurement. This could be due to high measurement noise (R) or high uncertainty in the predicted state (P). When S is large, the Kalman Gain (K) becomes smaller — so the filter makes only a small correction based on the measurement. It’s essentially saying: “This measurement might be unreliable, so let’s not overreact.”</li><li name="2fbf" id="2fbf" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Lower S</strong>: Means the predicted measurement aligns well with the actual sensor reading, and the noise levels are low. In this case, the Kalman Gain (K) becomes larger — so the filter gives more weight to the measurement when correcting the state. It’s saying: “We trust this sensor reading — let’s use it to strongly correct our estimate.”</li></ul><p name="c3c7" id="c3c7" class="graf graf--p graf-after--li">This mechanism balances prediction and measurement contributions, ensuring robust state estimation even in the presence of noisy data.</p><h4 name="0b30" id="0b30" class="graf graf--h4 graf-after--p">Mathematical Representation</h4><p name="6676" id="6676" class="graf graf--p graf-after--h4">The Innovation Covariance is defined as:</p><figure name="f5c4" id="f5c4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*2tmtHM3WHdufDkyeua6fXQ.png" data-width="680" data-height="137" src="https://cdn-images-1.medium.com/max/800/1*2tmtHM3WHdufDkyeua6fXQ.png"></figure><p name="fa2c" id="fa2c" class="graf graf--p graf-after--figure">where:</p><ul class="postList"><li name="ce78" id="ce78" class="graf graf--li graf-after--p">Hi: Measurement Jacobian matrix, representing the sensitivity of the predicted sensor outputs to changes in the state vector.</li><li name="252e" id="252e" class="graf graf--li graf-after--li">P: Covariance matrix from the prediction phase.</li><li name="d129" id="d129" class="graf graf--li graf-after--li">Ri: Measurement noise covariance matrix, initialized as a 3×3 identity matrix scaled by some starting value when the EKF instance was created. <strong class="markup--strong markup--li-strong">This matrix must be tuned experimentally.</strong></li></ul><h4 name="86e6" id="86e6" class="graf graf--h4 graf-after--li">Code Implementation</h4><p name="df66" id="df66" class="graf graf--p graf-after--h4">Below is the Rust implementation of computing the Innovation Covariance:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="a055" id="a055" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-comment">// 4. Compute innovation covariance: S = HPHᵀ + R</span><br />    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = h_jacobian * <span class="hljs-keyword">self</span>.covariance * h_jacobian.<span class="hljs-title function_ invoke__">transpose</span>() + <span class="hljs-keyword">self</span>.measurement_noise;Key Points:</span></pre><ul class="postList"><li name="5c4c" id="5c4c" class="graf graf--li graf-after--pre">The innovation covariance S directly impacts the Kalman Gain (K) calculation, which determines how much the state estimate should be adjusted in the update phase.</li><li name="38ab" id="38ab" class="graf graf--li graf-after--li">The R matrix reflects the sensor’s reliability and must be experimentally tuned to achieve an optimal balance between prediction and measurement data.</li></ul><p name="40a9" id="40a9" class="graf graf--p graf-after--li">This step completes the uncertainty modeling in the update phase, ensuring that corrections to the state vector are statistically grounded and responsive to both sensor quality and model confidence.</p><h3 name="f236" id="f236" class="graf graf--h3 graf-after--p">6.2.5 Calculate the Kalman Gain (K)</h3><p name="0d47" id="0d47" class="graf graf--p graf-after--h3">The <strong class="markup--strong markup--p-strong">Kalman Gain</strong> (K) is one of the most critical components of the Extended Kalman Filter. It optimally determines how much weight to assign to the measurement versus the prediction when updating the state estimate.</p><h4 name="2078" id="2078" class="graf graf--h4 graf-after--p">Purpose of the Kalman Gain</h4><p name="7cb9" id="7cb9" class="graf graf--p graf-after--h4">K ensures the EKF dynamically balances the relative trust between:</p><ol class="postList"><li name="4149" id="4149" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">State Prediction</strong>: The estimate based on the model dynamics from the prediction phase.</li><li name="f06c" id="f06c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Sensor Measurement</strong>: The actual measurement from the sensors in the update phase.</li></ol><h4 name="04c7" id="04c7" class="graf graf--h4 graf-after--li">Key Insights:</h4><ul class="postList"><li name="d6b0" id="d6b0" class="graf graf--li graf-after--h4">If the <strong class="markup--strong markup--li-strong">measurement uncertainty R</strong> is <strong class="markup--strong markup--li-strong">low</strong> (indicating a highly accurate sensor), K gives more weight to the measurement.</li><li name="930d" id="930d" class="graf graf--li graf-after--li">If the <strong class="markup--strong markup--li-strong">state prediction uncertainty P</strong> is <strong class="markup--strong markup--li-strong">low</strong> (indicating a high-confidence model prediction), K gives more weight to the prediction.</li><li name="01bf" id="01bf" class="graf graf--li graf-after--li">A <strong class="markup--strong markup--li-strong">high K</strong> means more trust in the measurement.</li><li name="dd3a" id="dd3a" class="graf graf--li graf-after--li">A <strong class="markup--strong markup--li-strong">low K</strong> means more trust in the prediction.</li></ul><p name="1737" id="1737" class="graf graf--p graf-after--li">The Kalman Gain enables the EKF to adapt dynamically in real-time to changing uncertainties in the system and sensor measurements.</p><h4 name="3b92" id="3b92" class="graf graf--h4 graf-after--p">Mathematical Representation</h4><p name="0c80" id="0c80" class="graf graf--p graf-after--h4">The Kalman Gain is calculated as:</p><figure name="8dc4" id="8dc4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*0GMo2TXymBtRCzY8aWdWSg.png" data-width="680" data-height="137" src="https://cdn-images-1.medium.com/max/800/1*0GMo2TXymBtRCzY8aWdWSg.png"></figure><p name="41dc" id="41dc" class="graf graf--p graf-after--figure">where:</p><ul class="postList"><li name="0620" id="0620" class="graf graf--li graf-after--p">P: Covariance matrix from the prediction phase, representing the prediction uncertainty.</li><li name="1822" id="1822" class="graf graf--li graf-after--li">Hi: Measurement Jacobian matrix, capturing how the state affects the measurement outputs.</li><li name="cac8" id="cac8" class="graf graf--li graf-after--li">S: Innovation covariance, quantifying the combined uncertainty of the prediction and the measurement.</li></ul><h4 name="07f6" id="07f6" class="graf graf--h4 graf-after--li">Practical Implications of K</h4><ol class="postList"><li name="c2d1" id="c2d1" class="graf graf--li graf-after--h4"><strong class="markup--strong markup--li-strong">Dynamic Balancing</strong>: Since K is recalculated at every iteration, the EKF continuously adjusts the balance between prediction and measurement.</li><li name="0341" id="0341" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Optimal Fusion</strong>: K ensures that the state update is performed in a statistically optimal way, leveraging both the system model and sensor data.</li><li name="c852" id="c852" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Error Reduction</strong>: The influence of K minimizes the overall error in the state estimation.</li></ol><h4 name="ef20" id="ef20" class="graf graf--h4 graf-after--li">Code Implementation</h4><p name="abed" id="abed" class="graf graf--p graf-after--h4">Below is the Rust implementation of the Kalman Gain:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="d6ed" id="d6ed" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-comment">// 5. Compute Kalman Gain: K = PHᵀS⁻¹</span><br />    <span class="hljs-keyword">let</span> <span class="hljs-variable">k</span> = <span class="hljs-keyword">self</span>.covariance * h_jacobian.<span class="hljs-title function_ invoke__">transpose</span>() * s_inv;</span></pre><p name="4e37" id="4e37" class="graf graf--p graf-after--pre">The Kalman Gain serves as the bridge between prediction and measurement, dynamically adjusting the system’s state estimate and ensuring robust performance in a noisy environment. It reflects the adaptability and power of the EKF.</p><h3 name="eebf" id="eebf" class="graf graf--h3 graf-after--p">6.2.6 Update the State Vector</h3><p name="1a28" id="1a28" class="graf graf--p graf-after--h3">In this step, the EKF <strong class="markup--strong markup--p-strong">refines its estimate of the system state</strong> by incorporating the sensor measurements (via the innovation) and the predicted state (via the Kalman Gain). This is the step where the “update” of the <strong class="markup--strong markup--p-strong">update phase</strong> happens.</p><h4 name="20c1" id="20c1" class="graf graf--h4 graf-after--p">Mathematical Representation:</h4><p name="a7a5" id="a7a5" class="graf graf--p graf-after--h4">The updated state vector is defined as:</p><figure name="d6cf" id="d6cf" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*GNOxmw0rdGYCGQckbTf8dA.png" data-width="680" data-height="137" src="https://cdn-images-1.medium.com/max/800/1*GNOxmw0rdGYCGQckbTf8dA.png"></figure><p name="03c9" id="03c9" class="graf graf--p graf-after--figure">where:</p><ul class="postList"><li name="5d47" id="5d47" class="graf graf--li graf-after--p">x̂ : Predicted state vector.</li><li name="b252" id="b252" class="graf graf--li graf-after--li">K: Kalman Gain, computed earlier.</li><li name="8ceb" id="8ceb" class="graf graf--li graf-after--li">y: Innovation (sensor error residual).</li></ul><p name="47f6" id="47f6" class="graf graf--p graf-after--li">The Kalman Gain (K) dynamically determines the influence of the measurement versus the prediction, and the Innovation (y) quantifies the difference between actual sensor data and predicted measurements. Together, they refine the state estimate to optimally fuse prediction and measurement.</p><h4 name="11bf" id="11bf" class="graf graf--h4 graf-after--p">Output:</h4><p name="966f" id="966f" class="graf graf--p graf-after--h4">This operation adjusts the quaternion and gyro biases in the state vector to reflect the most likely estimate, given both the system model and the new accelerometer measurement. The updated state vector contains:</p><ul class="postList"><li name="051d" id="051d" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">w</strong>: The real part of the quaternion</li><li name="72be" id="72be" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">x</strong>: The coefficient of the <code class="markup--code markup--li-code">i</code> component.</li><li name="3761" id="3761" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">y</strong>: The coefficient of the <code class="markup--code markup--li-code">j</code> component.</li><li name="b720" id="b720" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">z</strong>: The coefficient of the <code class="markup--code markup--li-code">k</code> component.</li><li name="bc8e" id="bc8e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">bx:</strong> Gyroscope bias around the x-axis.</li><li name="7d8c" id="7d8c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">by:</strong> Gyroscope bias around the y-axis.</li><li name="d1b3" id="d1b3" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">bz:</strong> Gyroscope bias around the z-axis.</li></ul><h4 name="b646" id="b646" class="graf graf--h4 graf-after--li">Code Implementation:</h4><p name="4b8d" id="4b8d" class="graf graf--p graf-after--h4">Below is the Rust implementation of updating the state vector:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="rust" name="28a0" id="28a0" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-comment">// 6. Update state estimate: x = x + K(z - h(x))</span><br />    <span class="hljs-keyword">self</span>.state += k * innovation;</span></pre><h3 name="96ee" id="96ee" class="graf graf--h3 graf-after--pre">6.2.7 Update the Covariance Matrix</h3><p name="cf67" id="cf67" class="graf graf--p graf-after--h3">This is the <strong class="markup--strong markup--p-strong">final step</strong> in the <strong class="markup--strong markup--p-strong">Update Phase</strong>, where the covariance matrix <code class="markup--code markup--p-code">P</code> is updated to reflect the reduced uncertainty after incorporating the measurement update.</p><h4 name="9449" id="9449" class="graf graf--h4 graf-after--p">Purpose:</h4><p name="2787" id="2787" class="graf graf--p graf-after--h4">The covariance matrix <code class="markup--code markup--p-code">P</code> represents the filter&#39;s belief about the uncertainty of its current state estimate. After correcting the state with real sensor data, the filter becomes more confident — and that reduced uncertainty is captured in this update.</p><h4 name="c68a" id="c68a" class="graf graf--h4 graf-after--p">Mathematical Representation:</h4><p name="b8ee" id="b8ee" class="graf graf--p graf-after--h4">The updated covariance matrix is defined as:</p><figure name="34bc" id="34bc" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*lZVe-Eqpah-2nZJcsFghjg.png" data-width="680" data-height="137" src="https://cdn-images-1.medium.com/max/800/1*lZVe-Eqpah-2nZJcsFghjg.png"></figure><p name="16b6" id="16b6" class="graf graf--p graf-after--figure">where:</p><ul class="postList"><li name="af3e" id="af3e" class="graf graf--li graf-after--p">I: Identity matrix of the same size as <code class="markup--code markup--li-code">P</code>.</li><li name="60f9" id="60f9" class="graf graf--li graf-after--li">K: Kalman Gain.</li><li name="667f" id="667f" class="graf graf--li graf-after--li">H: Measurement Jacobian matrix.</li><li name="4c63" id="4c63" class="graf graf--li graf-after--li">P: Covariance matrix before the update.</li></ul><p name="ac02" id="ac02" class="graf graf--p graf-after--li">This equation ensures that:</p><ol class="postList"><li name="6ce7" id="6ce7" class="graf graf--li graf-after--p">The uncertainty shrinks in directions where the measurement was informative.</li><li name="dd00" id="dd00" class="graf graf--li graf-after--li">The updated <code class="markup--code markup--li-code">P</code> is ready for use in the next EKF prediction phase.</li></ol><h4 name="c42e" id="c42e" class="graf graf--h4 graf-after--li">Code Implementation:</h4><p name="d4c8" id="d4c8" class="graf graf--p graf-after--h4">Below is the Rust implementation of updating the covariance matrix:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="php" name="f63c" id="f63c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-comment">// 7. Update covariance: P = (I - KH)P</span><br />    <span class="hljs-built_in">self</span>.covariance = (<span class="hljs-title class_">Matrix7</span>::<span class="hljs-title function_ invoke__">identity</span>() - k * h_jacobian) * <span class="hljs-built_in">self</span>.covariance;</span></pre><h4 name="a664" id="a664" class="graf graf--h4 graf-after--pre">Output:</h4><p name="2d05" id="2d05" class="graf graf--p graf-after--h4">The updated covariance matrix <code class="markup--code markup--p-code">P</code> now reflects the EKF’s improved confidence in the state estimate. It plays a key role in the next prediction phase — both in shaping the Kalman Gain and in tracking how uncertainty evolves over time.</p><h3 name="cf4a" id="cf4a" class="graf graf--h3 graf-after--p">6.2.8 Normalize the Quaternion</h3><p name="fcf7" id="fcf7" class="graf graf--p graf-after--h3">Quaternions must always be normalized to avoid accumulating errors. It is done here at the end of the update phase just as was done at the end of the predict phase.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="rust" name="21ca" id="21ca" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">    <span class="hljs-comment">// 8. Normalize quaternion again after update</span><br />    <span class="hljs-keyword">Self</span>::<span class="hljs-title function_ invoke__">normalize_quaternion_in_state</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.state);</span></pre><p name="48ba" id="48ba" class="graf graf--p graf-after--pre">These steps complete the <strong class="markup--strong markup--p-strong">Update Phase</strong> of the Extended Kalman Filter. With the <strong class="markup--strong markup--p-strong">prediction phase</strong> and <strong class="markup--strong markup--p-strong">update phase</strong> combined, the EKF is now ready to iterate and continuously refine its state estimate in real-time.</p><figure name="3d66" id="3d66" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*F8OjWzUilGp2PBkH" data-width="1125" data-height="750" src="https://cdn-images-1.medium.com/max/800/0*F8OjWzUilGp2PBkH"><figcaption class="imageCaption"><em class="markup--em markup--figure-em">Photo by </em><a href="https://www.pexels.com/@alessandro-oliverio-611273/" data-href="https://www.pexels.com/@alessandro-oliverio-611273/" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank"><em class="markup--em markup--figure-em">Alessandro Oliverio</em></a><em class="markup--em markup--figure-em"> on </em><a href="https://www.pexels.com/photo/silver-and-green-circuit-board-1472443/" data-href="https://www.pexels.com/photo/silver-and-green-circuit-board-1472443/" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank"><em class="markup--em markup--figure-em">Pexels</em></a></figcaption></figure><h3 name="926f" id="926f" class="graf graf--h3 graf-after--figure">7. Implementation and Results</h3><p name="2e4b" id="2e4b" class="graf graf--p graf-after--h3">With the EKF architecture complete and tuned for deployment, the next step was to validate its performance using real-world IMU data — collected directly from my Raspberry Pi–based sensor stack.</p><h3 name="e48a" id="e48a" class="graf graf--h3 graf-after--p">7.1 Software-in-the-Loop (SITL) Testing</h3><p name="1634" id="1634" class="graf graf--p graf-after--h3">To simulate a real-time estimation loop without risking actual flight hardware, I performed software-in-the-loop (SITL) testing using <strong class="markup--strong markup--p-strong">1,000,000 IMU samples</strong> recorded from an ICM-20948 sensor over SPI using a driver I also wrote in Rust. This dataset included synchronized gyroscope and accelerometer data sampled at approximately <strong class="markup--strong markup--p-strong">17 kHz</strong>, representing the real-world performance <strong class="markup--strong markup--p-strong">ceiling</strong> of my current embedded Rust driver.</p><p name="bc31" id="bc31" class="graf graf--p graf-after--p">To test the EKF itself, I wrote a benchmarking harness that:</p><ol class="postList"><li name="551c" id="551c" class="graf graf--li graf-after--p">Parsed the recorded CSV data into memory.</li><li name="c437" id="c437" class="graf graf--li graf-after--li">Ran the full EKF prediction and update cycles for each sample.</li><li name="e0bf" id="e0bf" class="graf graf--li graf-after--li">Collected the resulting state vectors.</li><li name="6caf" id="6caf" class="graf graf--li graf-after--li">Wrote the entire output to a new CSV for post-processing and visualization.</li></ol><p name="6a35" id="6a35" class="graf graf--p graf-after--li">By storing results in memory before writing to disk, I ensured the benchmark reflected only EKF processing performance — without I/O bottlenecks.</p><h3 name="fc48" id="fc48" class="graf graf--h3 graf-after--p">7.2 SITL Results</h3><p name="7bea" id="7bea" class="graf graf--p graf-after--h3">Running the full EKF on all <strong class="markup--strong markup--p-strong">1,000,000 samples</strong> in <strong class="markup--strong markup--p-strong">release mode</strong> (compiled with <code class="markup--code markup--p-code">cargo build --release</code>, which optimizes the code for speed) took only <strong class="markup--strong markup--p-strong">978 ms</strong>, yielding an effective processing rate of approximately <strong class="markup--strong markup--p-strong">1 MHz</strong>. This means the EKF runs over <strong class="markup--strong markup--p-strong">50x faster</strong> than the IMU can produce data.</p><p name="cb85" id="cb85" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">For context, these tests were conducted on a Raspberry Pi 4 running at 1.5 GHz.</em></p><p name="e37e" id="e37e" class="graf graf--p graf-after--p">This performance margin confirms that the estimator is nowhere near a computational bottleneck — even on consumer-grade hardware. Such headroom opens the door for implementing more complex filters, advanced sensor fusion models, or even adding concurrent tasks like logging and visualization without compromising real-time control.</p><figure name="8026" id="8026" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*LY7FroIY9Y8pR-xePybV0Q.png" data-width="1040" data-height="274" src="https://cdn-images-1.medium.com/max/800/1*LY7FroIY9Y8pR-xePybV0Q.png"><figcaption class="imageCaption">SITL Performance Results</figcaption></figure><p name="2ef7" id="2ef7" class="graf graf--p graf-after--figure">During SITL testing, I simulated realistic IMU conditions by manually manipulating the sensor. The procedure was as follows:</p><ol class="postList"><li name="a187" id="a187" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Initial Rest:</strong> The IMU was kept completely stationary for the first 10 seconds to establish a stable baseline.</li><li name="6fa1" id="6fa1" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Dynamic Motion:</strong> I then manually moved the IMU to various roll and pitch angles, simulating typical flight maneuvers.</li><li name="f9bd" id="f9bd" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Return to Rest:</strong> After the motion, the IMU was returned to a resting state for another 10 seconds to observe how quickly the filter converges back to a stable orientation.</li><li name="0a18" id="0a18" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Repeat Cycle:</strong> This cycle of dynamic motion followed by rest was repeated several times over a total test duration of about 50 seconds.</li></ol><p name="7cae" id="7cae" class="graf graf--p graf-after--li">This approach allowed me to capture both the dynamic response of the EKF during motion and its steady-state behavior during periods of rest, confirming that the filter accurately tracks orientation changes and quickly stabilizes when the sensor is at rest.</p><figure name="23f8" id="23f8" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*II-HiF4mlKjmS7J6q559ag.png" data-width="3000" data-height="1500" src="https://cdn-images-1.medium.com/max/800/1*II-HiF4mlKjmS7J6q559ag.png"><figcaption class="imageCaption">SITL Test Data</figcaption></figure><h3 name="d5b8" id="d5b8" class="graf graf--h3 graf-after--figure">7.3 Hardware-in-the-Loop (HITL) Testing</h3><figure name="6ae5" id="6ae5" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*WLIoW485MYMno6RKVtBxPw.png" data-width="4003" data-height="3266" src="https://cdn-images-1.medium.com/max/800/1*WLIoW485MYMno6RKVtBxPw.png"><figcaption class="imageCaption">ROS2 Perception Layer</figcaption></figure><p name="a4f0" id="a4f0" class="graf graf--p graf-after--figure">To validate the EKF on actual hardware, I created a <strong class="markup--strong markup--p-strong">ROS2-based perception pipeline</strong> that integrates my custom IMU and EKF drivers. As shown in the diagram above, this architecture uses two primary ROS2 nodes:</p><ol class="postList"><li name="4451" id="4451" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">imu_publisher</strong></code><strong class="markup--strong markup--li-strong"> Node</strong></li></ol><ul class="postList"><li name="b2be" id="b2be" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Imports the IMU driver</strong> (icm20948-driver-rust) to communicate with the physical ICM-20948 sensor over SPI.</li><li name="8a90" id="8a90" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Publishes</strong> the raw accelerometer and gyroscope data to a ROS2 topic named <code class="markup--code markup--li-code">/raw_imu</code>.</li></ul><p name="042f" id="042f" class="graf graf--p graf-after--li">2. <code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">sensor_fusion</strong></code><strong class="markup--strong markup--p-strong"> Node</strong></p><ul class="postList"><li name="7f30" id="7f30" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Subscribes</strong> to the <code class="markup--code markup--li-code">/raw_imu</code> topic, receiving IMU readings in real time.</li><li name="90ff" id="90ff" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Runs the EKF</strong> (via the rust-ekf crate) to fuse gyro and accelerometer data into a stable 3D orientation estimate.</li><li name="a9aa" id="a9aa" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Publishes</strong> the resulting quaternion on the <code class="markup--code markup--li-code">/quaternion_estimate</code> topic.</li></ul><p name="3dae" id="3dae" class="graf graf--p graf-after--li">ROS2 acts as the middleware for message passing between these nodes, making it straightforward to add additional processing steps or sensors later. Tools like <strong class="markup--strong markup--p-strong">RViz2</strong> allow for real-time visualization of the estimated orientation, while <strong class="markup--strong markup--p-strong">rqt_plot</strong> can graph raw vs. estimated data for debugging and performance analysis. Together, these components form the foundation of a hardware-in-the-loop (HITL) testing pipeline, where real sensor data is streamed into the EKF in real time to confirm the filter’s correctness and responsiveness under actual operating conditions. For this testing harness I published IMU data at 1 kHz.</p><h3 name="392e" id="392e" class="graf graf--h3 graf-after--p">7.4 Yaw Locking for Focused Tuning</h3><p name="d490" id="d490" class="graf graf--p graf-after--h3">In this implementation, yaw is deliberately “locked” during testing. Because the accelerometer cannot directly observe yaw (rotation around the gravity vector), the EKF’s update phase cannot correct yaw drift. Furthermore, without an external yaw reference, small errors in roll/pitch estimation can be misinterpreted as large yaw changes, leading to instability, especially at steep angles. Therefore, the filter is currently tuned to accurately estimate roll and pitch while keeping yaw constant. This deliberate yaw locking allows me to isolate and optimize the filter’s performance on the axes where reliable measurements are available, simplifying the tuning process.</p><p name="9a48" id="9a48" class="graf graf--p graf-after--p">Once a yaw-correcting sensor — such as a magnetometer or GPS-based heading sensor — is integrated into the system, I plan to unlock yaw in the EKF. This will enable full 3D orientation estimation without sacrificing the stability and responsiveness achieved during the roll and pitch tuning phase.</p><h3 name="9360" id="9360" class="graf graf--h3 graf-after--p">7.5 Filter Tuning and Visualization</h3><p name="6027" id="6027" class="graf graf--p graf-after--h3">Optimizing the EKF required iterative tuning of the process noise (Q) and measurement noise (R) matrices. To achieve both stability and responsiveness in the orientation estimates, I relied heavily on visualization tools provided by ROS2:</p><ul class="postList"><li name="ecc5" id="ecc5" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">RViz2:</strong><br> Using RViz2, I visualized the quaternion estimate in real time. This allowed me to observe the 3D orientation of the UAV as reported by the EKF. By watching the virtual model, I could identify moments of instability or excessive oscillations, particularly during rapid motions.<br> For example, when the UAV was manually manipulated, any overcorrections or jitter in the orientation were immediately visible. This real-time feedback was critical for adjusting the Q matrix values to ensure that the filter neither overreacted to noise nor underreacted to genuine motion.</li><li name="9a7c" id="9a7c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">rqt_plot:</strong><br> In parallel, I used rqt_plot to generate real-time plots of the IMU sensor data alongside the EKF outputs. This side-by-side comparison allowed me to compare the raw accelerometer and gyroscope data with the EKF’s quaternion estimate over time. By analyzing these plots, I fine-tuned the R matrix to achieve an optimal balance between trusting the accelerometer measurements (which are stable in the long term) and the gyroscope data (which offers high-frequency dynamics but suffers from drift).</li></ul><figure name="695d" id="695d" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="1*WvRVcN-MhLvLC6B47FRd6A.gif" data-width="800" data-height="328" src="https://cdn-images-1.medium.com/max/800/1*WvRVcN-MhLvLC6B47FRd6A.gif"><figcaption class="imageCaption">rqt_plot and RViz2 side-by-side demo</figcaption></figure><p name="7458" id="7458" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">Tuning Process:</strong></p><ol class="postList"><li name="1673" id="1673" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Initial Setup: </strong>I began by setting preliminary values for the Q and R matrices based on expected sensor noise levels.</li><li name="ff7a" id="ff7a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Iterative Adjustment: </strong>With RViz2 and rqt_plot, I observed the EKF’s response to various maneuvers:</li></ol><ul class="postList"><li name="ba7f" id="ba7f" class="graf graf--li graf-after--li">When the orientation oscillated excessively, I increased the process noise (Q) on the quaternion components to allow for smoother convergence.</li><li name="0a99" id="0a99" class="graf graf--li graf-after--li">If the filter appeared sluggish or unresponsive to actual motion, I reduced the measurement noise (R) to give more weight to the accelerometer’s gravity measurements.</li></ul><p name="859e" id="859e" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong">3. Validation: </strong>After each tuning iteration, I validated the results by checking that the quaternion remained normalized and that the EKF responded predictably during both rapid and slow movements.</p><p name="fd12" id="fd12" class="graf graf--p graf-after--p">This rigorous visualization and tuning approach ensured that the EKF maintained a stable and responsive orientation estimate, paving the way for robust integration into a real UAV control system.</p><figure name="769a" id="769a" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*IFqcGZDEtqzyd4oZYbo9Rw.gif" data-width="800" data-height="550" src="https://cdn-images-1.medium.com/max/800/1*IFqcGZDEtqzyd4oZYbo9Rw.gif"><figcaption class="imageCaption">RViz2 Simulation</figcaption></figure><h3 name="fcf5" id="fcf5" class="graf graf--h3 graf-after--figure">7.6 Hardware Testing Conclusion</h3><p name="7c86" id="7c86" class="graf graf--p graf-after--h3">After extensive tuning using RViz2 and rqt_plot, the EKF performed exceptionally well during hardware testing. Once tuned, the filter provided an orientation estimate that was both accurate and highly responsive in real time. Notably, the filter was sensitive enough to capture the minute unsteadiness in my hand when I manually moved the sensor, yet it stabilized perfectly when the device was at rest.</p><p name="6c37" id="6c37" class="graf graf--p graf-after--p">This robust performance confirms that the EKF’s design — especially the careful handling of gyroscope bias and the deliberate yaw locking — effectively mitigates sensor noise and drift. With these results, the filter is ready for integration into a full UAV control stack, and future enhancements like yaw correction via a magnetometer or GPS can be seamlessly incorporated without reworking the core estimation algorithm.</p><h3 name="4174" id="4174" class="graf graf--h3 graf-after--p">8. Next Steps</h3><p name="d4ad" id="d4ad" class="graf graf--p graf-after--h3">This EKF and real-time perception pipeline represent just one part of a much larger UAV project I’m developing. Future work will focus on further sensor fusion and control integration to build a complete, robust flight system:</p><ol class="postList"><li name="ee38" id="ee38" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Integrate a Magnetometer for Yaw Correction:</strong><br> Currently, yaw is locked to simplify tuning using only accelerometer and gyroscope data. The next phase is to add a magnetometer (or another heading sensor) to correct yaw drift, enabling full 3D orientation estimation.</li><li name="c379" id="c379" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Assemble the Full Quadcopter Hardware:</strong><br> I plan to integrate the EKF and perception pipeline into a complete quadcopter platform, including flight electronics and a custom radio control system.</li><li name="b3c2" id="b3c2" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Develop a Control Layer:</strong><br> A cascaded PID controller will be implemented for stable flight, leveraging the EKF’s accurate orientation estimates. This control layer, combined with radio control inputs, will form the backbone of the UAV’s real-time flight control system.</li><li name="512a" id="512a" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Expand to a Full INS (Inertial Navigation System):</strong><br> In later stages, the state vector will be extended beyond the current 7 states. The envisioned INS stack will potentially include:</li></ol><ul class="postList"><li name="c10a" id="c10a" class="graf graf--li graf-after--li">The current 7 states (quaternion + gyro bias)</li><li name="2916" id="2916" class="graf graf--li graf-after--li">3 additional states for magnetic field estimation (if using a magnetometer)</li><li name="7dcc" id="7dcc" class="graf graf--li graf-after--li">3 states for velocity</li><li name="c617" id="c617" class="graf graf--li graf-after--li">3 states for position</li></ul><p name="bb96" id="bb96" class="graf graf--p graf-after--li">This 16-state vector will serve as the foundation for advanced navigation algorithms, supporting GPS and even vision-based guidance for operation in GPS-denied environments.</p><p name="d8ed" id="d8ed" class="graf graf--p graf-after--p">Together, these steps will transition the project from a robust orientation estimator to a fully integrated, autonomous UAV capable of precise navigation and control in complex environments.</p><h3 name="70a6" id="70a6" class="graf graf--h3 graf-after--p">9. Conclusion</h3><p name="444d" id="444d" class="graf graf--p graf-after--h3">In this article, I detailed how I built a quaternion-based Extended Kalman Filter for UAV attitude estimation from scratch in Rust. By fusing raw gyroscope and accelerometer data I achieved a robust, high-frequency orientation estimator that operates in real time. Software-in-the-loop tests demonstrated that the filter runs at over 1 MHz, far exceeding the sensor’s sampling rate, while hardware tests confirmed that the EKF accurately tracks even the subtle movements of a hand-held sensor at a 1 kHz sampling rate.</p><p name="0946" id="0946" class="graf graf--p graf-after--p">This work not only showcases the performance and safety benefits of Rust in embedded and robotics applications but also lays a solid foundation for a larger UAV project. Looking ahead, I plan to integrate additional sensors — such as a magnetometer for full 3D orientation — develop a cascaded PID control system for stable flight, and eventually expand the filter into a complete inertial navigation system capable of operating in GPS-denied environments.</p><p name="7749" id="7749" class="graf graf--p graf-after--p">Ultimately, this project exemplifies a systematic, data-driven approach to sensor fusion and real-time state estimation — an approach that can be scaled and adapted to meet the challenges of autonomous UAV flight.</p><h3 name="e9ab" id="e9ab" class="graf graf--h3 graf-after--p">10. Resources</h3><p name="34eb" id="34eb" class="graf graf--p graf-after--h3">🔗 <a href="https://github.com/OrlandoQuintana/rust-ekf" data-href="https://github.com/OrlandoQuintana/rust-ekf" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Extended Kalman Filter GitHub Repository</a></p><p name="08d5" id="08d5" class="graf graf--p graf-after--p graf--trailing"><em class="markup--em markup--p-em">About the author:</em><br> <em class="markup--em markup--p-em">Orlando Quintana is a robotics engineer and systems programmer building custom flight stacks in Rust. He writes about embedded systems, real-time control, and autonomy. You can follow him on </em><a href="https://github.com/OrlandoQuintana" data-href="https://github.com/OrlandoQuintana" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">GitHub</em></a><em class="markup--em markup--p-em"> or connect on </em><a href="http://www.linkedin.com/in/orlando-p-quintana" data-href="http://www.linkedin.com/in/orlando-p-quintana" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><em class="markup--em markup--p-em">LinkedIn</em></a><em class="markup--em markup--p-em">.</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@opinoquintana" class="p-author h-card">Orlando Quintana</a> on <a href="https://medium.com/p/b8748ff33b12"><time class="dt-published" datetime="2025-04-01T15:09:24.687Z">April 1, 2025</time></a>.</p><p><a href="https://medium.com/@opinoquintana/i-wrote-an-extended-kalman-filter-for-uav-attitude-estimation-from-scratch-in-rust-b8748ff33b12" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on April 1, 2025.</p></footer></article></body></html>